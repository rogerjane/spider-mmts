#if 0
./makeh $0
exit 0
#endif

#include <limits.h>

extern void Log(const char *, ...);

#include "mtwamp.h"

#include <string.h>
#include <time.h>

#include <mtmacro.h>
#include <heapstrings.h>

#define STATIC static
#define API

#define WAMP_CONN_WEBSOCKET		1
#define WAMP_CONN_RAWSOCKET		2
#define WAMP_CONN_CODE			3

#if 0
// START HEADER

#include "smap.h"

#include "mtwebsocket.h"
#include "mtjson.h"

#define IDMAP	SPMAP

// Typedefs for WAMP callback functions
struct WAMP;
typedef int (*WAMPCB_NoCallee)(const char *name);
typedef void (*WAMPCB_Invokee)(struct WAMP *wamp, long long requestId, const char *procedure, JSON *list, JSON *dict);
typedef void (*WAMPCB_Data)(struct WAMP *wamp, JSON *json);
typedef int (*WAMPCB_Handler)(struct WAMP *wamp, int type, JSON *json);
typedef void (*WAMPCB_DeleteCallback)(struct WAMP *wamp);

typedef struct WAMP {
	const char *name;				// Unique ID for this wamp
	int connectionType;				// 1 = websocket, 2 = rawsocket, 3 = code (not currently implemented)
	union {
		WS *ws;						// The websocket this WAMP lives on
		WAMPCB_Data fn;				// Call back routine for code-based WAMPS
	} connection;
	IDMAP *handlers;
	HLIST *saveOutput;				// If non-null, receives a copy of all output
	HLIST *saveInput;				// If non-null, receives a copy of all input
	void *info;								// Miscellaneous info owned by the thing creating this WAMP
	struct WAMPREALM *realm;
	struct WAMPSESSION *session;
	WAMPCB_DeleteCallback cb_ondelete;		// Called just before object deleted
	char deleting;							// 1 while actually deleting
	char masked;							// Non-0 if we want to send outgoing masks
} WAMP;

#define WAMP_EXACT			1		// Used in wamp_RegisterCallee
#define WAMP_PREFIX			2
#define WAMP_WILDCARD		3

#define WAMP_HELLO			1
#define WAMP_WELCOME		2
#define WAMP_ABORT			3
#define WAMP_GOODBYE		6

#define WAMP_ERROR			8

#define WAMP_PUBLISH		16
#define WAMP_PUBLISHED		17

#define WAMP_SUBSCRIBE		32
#define WAMP_SUBSCRIBED		33
#define WAMP_UNSUBSCRIBE	34
#define WAMP_UNSUBSCRIBED	35
#define WAMP_EVENT			36

#define WAMP_CALL			48
#define WAMP_RESULT			50

#define WAMP_REGISTER		64
#define WAMP_REGISTERED		65
#define WAMP_UNREGISTER		66
#define WAMP_UNREGISTERED	67
#define WAMP_INVOCATION		68
#define WAMP_YIELD			70

// END HEADER
#endif

// Start at 1, WAMP_INVOKE_COUNT must be right
#define WAMP_INVOKE_SINGLE		1
#define WAMP_INVOKE_ROUNDROBIN	2
#define WAMP_INVOKE_RANDOM		3
#define WAMP_INVOKE_FIRST		4
#define WAMP_INVOKE_LAST		5

#define WAMP_INVOKE_COUNT		5

// Start at 1, WAMP_CALLTYPE_COUNT must be right
#define WAMP_CALLTYPE_EXACT		1
#define WAMP_CALLTYPE_PREFIX	2
#define WAMP_CALLTYPE_WILDCARD	3

#define WAMP_CALLTYPE_COUNT		3

typedef struct WAMPREALM {
	const char *name;
	SPMAP *calleeMapExact;						// Map of known callees with exact call
	SPMAP *calleeMapPrefix;						// Map of known callees	with prefix call
	SPMAP *calleeMapWildcard;					// Map of known callees with wildcard call
	IDMAP *redirect;							// Re-direction map (see. wamp_RegisterRedirect())

	SPMAP *subMapExact;							// Three maps to handle subsscriptions
	SPMAP *subMapPrefix;
	SPMAP *subMapWildcard;
	IDMAP *allSubscriptions;					// All subscriptions by subscription ID

// wantForwardSubscriptions = 0									We are handling subscriptions
// wantForwardSubscriptions = 1, forwardSubscriptions != NULL	We can't handle them, but we can forward them
// wantForwardSubscriptions = 1, forwardSubscriptions = NULL	We can't handle them at all
	int wantForwardSubscriptions;				// 1 if we want to forward subscriptions
	const char *forwardSubscriptions;			// WAMP to which to forward subscriptions or NULL not to forward
	SSMAP *fwdSubscriptionMap;					// Records who is subscribing to messages
	SSMAP *fwdUnsubscriptionMap;				// Records who is unsubscribing to messages
	SSMAP *fwdEventMap;							// Records who wants to know about events
	SSMAP *fwdPublishMap;						// Records who has published
} WAMPREALM;

typedef struct WAMPSESSION {
	long long id;
	WAMPREALM *realm;
} WAMPSESSION;

/* WAMP ROUTING


# Do we want / need to be able to advertise a callee and address it from anywhere?
# E.g. snomed.register might be provided on a specific server, but we don't want the caller to need to know that.

# Would we, therefore, want a list of 'advertised' callees on each node, which gets distributed when a node sends
# a discovery message?  Also, presumably, if a node sees one of these come or go.
# Don't want to have a specific 'global' realm for this as callers register with only one.

	For this to work, each node is going to have to know which neighbours it has and will need a unique name.

	Message format is:

		[MTPOST, messageID|id, destination|String, source|String, visited|array, details|Dict, [normal message content]]

		MTPOST		- Our own message type for routing

		messageId		- Unique message ID generated by sender
		destination		- Unique ID of the destination node or "*" for a broadcast
		source			- The original sender of the message

		visited			- Array of nodes this message has visited (unsure whether to include sender)

		details:
			Expiry		- Date				When this message can be forgotten about (default to +1h)
			PleaseAck	- bool				True if sender requires delivery acknowledgement
			Hops		- integer			How many hops this message has taken (only in discovery)
			Aliases		- Array of Strings	Aliases under which this node can be referred

		message			- normal message	Omitted for a discovery message

	On startup, node sends 'discovery' broadcast via every neighbour
		Contains no content

	On receiving any message:
		If not seen before (only needs to be since startup?):
			Add to 'seen' list (ID, expiry)
		else
			flag as 'duplicate'
		Process message

	On receiving a broadcast (destination = "*"):
		flag as 'broadcast'
		If not duplicate OR is discovery:
			Process message
		If not duplicate:			(Needs to be last as a response might need the above processing to be done to work properly)
			Send to all neighbours not on visited list

	Processing 'discovery':
		Record in route table (sender, hops, neighbour)
		If it was a broadcast:
			Send 'discovery' message direct to sender
		If it was direct:
			Forward as a broadcast to other neighbours

	Processing anything else:
		if duplicate, forget it (mentioned above).

	On receiving any direct message to me:
		If I am sender, process as 'failed to deliver'
		If 'PleaseAck' send 'ack' to sender
		Process the message

	On receiving any direct message to another (X):
		If it is discovery, increment 'details.hops'
		Forward on to a neighbour as for 'On sending to X' below

	On originating a message to X:
		Set sender to self
		Send to X as below:

	On Sending to another (X):
		Add self to 'visited' array
		Find 'X' in route table
		Send to matching neighbour with smallest hop count, not visited

		If there is no matching neighbour, not visited:
			If forwarding (came from neighbour)
				Send back to previous neighbour
			else
				Send to self

		If cannot deliver to neighbour:
			Set its hop count to MAX
			Try next in table

	Failed to deliver:
		This means the message has failed to reach the recipient.

Questions:
	Q: If we receive a message with no visited and the sender is not on our neighbours table, do we add it?
		A: Should never happen, but if already known and hop count in route table == MAX, then reset the hops in the route table?

	Q: How often should we send 'reminder' discovery messages
	Q: When should we 'ping' our neighbours?
		A: Depends on the reliability - let's see how it works out

	Q: Not sure of the use-case for 'PleaseAck' but I'm sure there is one

	Q: Can this be done using external connections to this wamp handling?
		A: I think so!

	Q: When receiving a discovery we may choose not to reply if we have no services to offer, or ignore it if we have no use for it.
		A: If we don't do this, every route table will have all known nodes.  Not sure if this is needed or no.

	Q: Where do we configure neighbours?
		A simple text file somewhere.  Distinct from spider.conf but needs to be one per node and there are several per server.

What achieves this?
	Call from outside WAMP to add handler for message type: 100 = MTPOST
		This should be done by adding an internal WAMP* and saying it should receive all MTPOST messages
	Call WAMP to make connection to each known neighbour
	Send the initial discovery message as above
	When we receive MTPOST, if it's a discovery then reply only if it's a broadcast.
	If it's not a broadcast, re-transmit it as a broadcast, keeping hops and visited intact.

*/

typedef struct wamp_invokee_t {
	int	priority;
	const char *wampName;
	WAMPCB_Invokee cb_invokee;
} wamp_invokee_t;

typedef struct wamp_call_t {								// Holds information about an active call
	const char *callerWampName;								// The name of the calling wamp
	long long callerRequestId;
	const char *calleeWampName;								// The name of the calling wamp
	long long calleeRequestId;
	wamp_invokee_t *invokee;
} wamp_call_t;

typedef struct wamp_callee_t {
	const char *procedure;									// The name of the procedure that these callees handle
	long long registrationId;								// Id under which callee registered
	int roundRobinCount;
	int nInvokees;											// Number of invokees servicing this call
	wamp_invokee_t **invokee;
	int invokePolicy;										// WAMP_INVOKE_SINGLE ... WAMP_INVOKE_LAST
	int highestPriority;									// Highest priority of any invokees
} wamp_callee_t;

typedef struct subscription_info_t {
	long long requestId;
} subscription_info_t;

typedef struct subscription_t {
	long long subscriptionId;
	SPMAP *wamps;											// Maps the WAMPS (by name) that are subscribed, to their requestIds
} subscription_t;

STATIC SPMAP *allWamps = NULL;								// All active wamps by name
STATIC IDMAP *activeCallMap = NULL;							// Active calls - points to wamp_invokee_t
STATIC WAMPCB_NoCallee wampcb_NoCallee = NULL;				// Callback function if there is no callee
STATIC WAMPCB_Invokee wampcb_Invokee = NULL;				// Callback function when a procedure is invoked

STATIC struct wamp_code_t {
	int code;
	const char *name;
} wamp_codes[] = {
	{WAMP_HELLO,			"Hello"},
	{WAMP_WELCOME,			"Welcome"},
	{WAMP_ABORT,			"Abort"},
	{WAMP_GOODBYE,			"Goodbye"},

	{WAMP_ERROR,			"Error"},

	{WAMP_PUBLISH,			"Publish"},
	{WAMP_PUBLISHED,		"Published"},

	{WAMP_SUBSCRIBE,		"Subscribe"},
	{WAMP_SUBSCRIBED,		"Subscribed"},
	{WAMP_UNSUBSCRIBE,		"Unsubscribe"},
	{WAMP_UNSUBSCRIBED,		"Unsubscribed"},
	{WAMP_EVENT,			"Event"},

	{WAMP_CALL,				"Call"},
	{WAMP_RESULT,			"Result"},

	{WAMP_REGISTER,			"Register"},
	{WAMP_REGISTERED,		"Registered"},
	{WAMP_UNREGISTER,		"Unregister"},
	{WAMP_UNREGISTERED,		"Unregistered"},
	{WAMP_INVOCATION,		"Invocation"},
	{WAMP_YIELD,			"Yield"},

	{0,NULL}
};

// IDMAP - maps long long to pointer
// The map is really string to pointer but the long long keys are converted to strings

IDMAP *idmap_New()												{ return (IDMAP*)spmap_New(); }
void idmap_Delete(IDMAP *im)									{ spmap_Delete((SPMAP*)im); }
void idmap_Reset(IDMAP *im)										{ spmap_Reset((SPMAP*)im); }
void idmap_Clear(IDMAP *im)										{ spmap_Clear((SPMAP*)im); }
int idmap_Count(IDMAP *im)										{ return spmap_Count((SPMAP*)im); }
void idmap_Sort(IDMAP *im, int (*sorter)(const char *, const char *)) { spmap_Sort((SPMAP*)im, sorter); }
void idmap_SortValues(IDMAP *im, int (*sorter)(const char *, const char *)) { spmap_SortValues((SPMAP*)im, sorter); }
void *idmap_GetValueAtIndex(IDMAP *im, int index)                 { return spmap_GetValueAtIndex((SPMAP*)im, index); }

int idmap_GetNextEntry(IDMAP *im, long long *pKey, void **pValue)
{
	const char *key;

	int result = spmap_GetNextEntry((SPMAP*)im, &key, pValue);
	if (pKey) *pKey = atoll(key);

	return result;
}

int idmap_DeleteKey(IDMAP *im, long long id)
{
	char key[18];

	sprintf(key, "%Lx", id);
	return spmap_DeleteKey((SPMAP*)im, key);
}

long long idmap_GetKeyAtIndex(IDMAP *im, int index)
{
	long long result = 0;
	const char *key = spmap_GetKeyAtIndex((SPMAP*)im, index);

	if (key) result = atoll(key);

	return result;
}

int idmap_Add(IDMAP *im, long long id, void *value)
{
	char key[18];

	sprintf(key, "%Lx", id);

	return spmap_Add((SPMAP*)im, key, value);
}

void *idmap_GetValue(IDMAP *im, long long id)
{
	char key[18];

	sprintf(key, "%Lx", id);

	return spmap_GetValue((SPMAP*)im, key);
}

long long idmap_GetKey(SIMAP *im, void *value)
{
	long long result = 0;
	const char *key = spmap_GetKey((SPMAP*)im, value);

	if (key) sscanf(key, "%Lx", &result);

	return result;
}

//////////////////////

// Connection provided an incorrect URI for any URI-based attribute of WAMP message,
// such as realm, topic or procedure.
STATIC const char *ErrInvalidUri = "wamp.error.invalid_uri";

// A Dealer could not perform a call, since no procedure is currently
// registered under the given URI.
STATIC const char *ErrNoSuchDomain = "wamp.error.no_such_procedure";

// A procedure could not be registered, since a procedure with the given URI
// is already registered.
STATIC const char *ErrDomainAlreadyExists = "wamp.error.procedure_already_exists";

// A Dealer could not perform an unregister, since the given registration is
// not active.
STATIC const char *ErrNoSuchRegistration = "wamp.error.no_such_registration";

// A Broker could not perform an unsubscribe, since the given subscription is
// not active.
STATIC const char *ErrNoSuchSubscription = "wamp.error.no_such_subscription";

// A call failed, since the given argument types or values are not acceptable
// to the called procedure - in which case the Callee may throw this error. Or
// a Node performing payload validation checked the payload (args / kwargs)
// of a call, call result, call error or publish, and the payload did not
// conform - in which case the Node may throw this error.
STATIC const char *ErrInvalidArgument = "wamp.error.invalid_argument";

// The Connection is shutting down completely - used as a GOODBYE (or aBORT) reason.
STATIC const char *ErrSystemShutdown = "wamp.error.system_shutdown";

// The Connection wants to leave the realm - used as a GOODBYE reason.
STATIC const char *ErrCloseRealm = "wamp.error.close_realm";

// A Connection acknowledges ending of a session - used as a GOOBYE reply reason.
STATIC const char *ErrGoodbyeAndOut = "wamp.error.goodbye_and_out";

// A join, call, register, publish or subscribe failed, since the Connection is not
// authorized to perform the operation.
STATIC const char *ErrNotAuthorized = "wamp.error.not_authorized";

// A Dealer or Broker could not determine if the Connection is authorized to perform
// a join, call, register, publish or subscribe, since the authorization
// operation itself failed. E.g. a custom authorizer ran into an error.
STATIC const char *ErrAuthorizationFailed = "wamp.error.authorization_failed";

// Connection wanted to join a non-existing realm (and the Node did not allow to
// auto-create the realm)
STATIC const char *ErrNoSuchRealm = "wamp.error.no_such_realm";

// A Connection was to be authenticated under a Role that does not (or no longer)
// exists on the Node. For example, the Connection was successfully authenticated,
// but the Role configured does not exists - hence there is some
// misconfiguration in the Node.
STATIC const char *ErrNoSuchRole = "wamp.error.no_such_role";

STATIC int wamp_IsSubscriptionType(int type)
{
	return type >= WAMP_PUBLISH && type < WAMP_CALL;
}

STATIC int wamp_IsCallType(int type)
{
	return type >= WAMP_CALL && type <= WAMP_YIELD;
}

API const char *wamp_Name(WAMP *w)
// Returns the name of a WAMP.  This can later be used in wamp_ByName().
// If you want to refer to a WAMP later, using a name is safer as WAMPs can be deleted...
// WAMP *savedWamp = myWamp; ...... time passes .......  wamp_WriteJson(savedWamp, ...) can fail if it's been deleted in the middle
// const char *savedWamp = wamp_Name(myWamp); .....  WAMP *wamp = wamp_ByName(savedWamp); if (wamp) wamp_WriteJson(... is safe.
{
	return w ? w->name : NULL;
}

API const char *wamp_TypeName(int type)
// Given a WAMP message type number, returns the name
{
	struct wamp_code_t *rover = wamp_codes;

	while (rover->code) {
		if (rover->code == type)
			return rover->name;
		rover++;
	}

	return "Unknown wamp message type";
}
STATIC const char *TimeNow()
{
	static char result[24];

	time_t now = time(NULL);
	struct tm *tm = gmtime(&now);
	snprintf(result, sizeof(result), "%04d-%02d-%02dT%02d:%02d:%02d",
			tm->tm_year+1900, tm->tm_mon+1, tm->tm_min,
			tm->tm_hour, tm->tm_min, tm->tm_sec);

	return result;
}

STATIC const char *NiceBuf(int len, const char *buf)
{
	static char *result = NULL;

	if (result) free(result);
	if (len < 0) len = strlen(buf);

	HBUF *hbuf = hbuf_New();

	char *dest = result;
	while (len > 0) {
		if (*buf >= ' ' && *buf <= '~') {
			hbuf_AddChar(hbuf, *buf);
		} else {
			char tmp[10];
			snprintf(tmp, sizeof(tmp), "<%02x>", (unsigned char)*buf);
			hbuf_AddBuffer(hbuf, -1, tmp);
		}
		buf++;
		len--;
	}
	hbuf_AddChar(hbuf, '\0');
	result = (char*)hbuf_ReleaseBuffer(hbuf);
	hbuf_Delete(hbuf);

	return result;
}

STATIC LogString(WAMP *wamp, const char *prefix, const char *string)
{
	const char *name = "?";
	if (string && *string == '[') {
		name = wamp_TypeName(atoi(string+1));
	}
	const char *wampName = wamp_Name(wamp);
	if (!wampName) wampName = "NULL";

	Log("WA: %-8s(%s): %s - %s", prefix, wampName, name, NiceBuf(-1, string));
}

API long long wamp_RandomId()
// Returns a random number 1..2^53-1
{
	static int seeded = 0;

	if (!seeded) {
		seeded = 1;
		srand48(time(NULL));
	}

	long long result = 0;
	while (result == 0) {	// Dangerous but if it doesn't exit, the random number generator has gone weird, which would be spooky
		long long a = lrand48();						// Unsigned
		long long b = lrand48();						// Unsigned
		result = (a ^ (b<<32)) & 0x1fffffffffffffL;		// XOR them and take the bottom 53 bits
	}

	return result;
}

int wamp_HandleIncomingData(WS *ws, int len, const char *text)
// This function handles UTF8 data coming in on the WebSocket channel.
// Currently this can only be destined for the WAMP system and this is effectively the interface function.
// Returns	0		All went well and was handled
//			1...	Fatal error - close connection
{
Log("WA: WS-IN(%s): %.*s", ws->name, len, text);

	WAMP *wamp = ws_Info(ws);

	if (wamp && wamp->saveInput) {
		hlist_Add(wamp->saveInput, len, text);
		hlist_Add(wamp->saveInput, 1, "\n");
	}

	JSON *j = json_Parse(&text);

	const char *err = json_Error(j);
	if (err) {
		wamp_SendErrorStr(wamp, 0, 0, "Failed to parse JSON", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	if (json_Type(j) != JSON_ARRAY) {
		wamp_SendErrorStr(wamp, 0, 0, "JSON message must be an array", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	if (json_ArrayCount(j) < 1) {
		wamp_SendErrorStr(wamp, 0, 0, "Message must have at least one element", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	JSON *element1 = json_ArrayAt(j, 0);
	if (json_Type(element1) != JSON_INTEGER) {
		wamp_SendErrorStr(wamp, 0, 0, "Message type must be an integer", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	int messageType = json_AsInteger(element1);

	int result = wamp_Dispatch(wamp, messageType, j);
	json_Delete(j);

	return result;
}

API WAMP *wamp_SetInfo(WAMP *w, void *info)
// Sets the 'info' data for this wamp.  This is not used by the wamp itself but is available for the caller
{
	WAMP *previous = NULL;
	if (w) {
		previous = w->info;
		w->info = info;
	}

	return previous;
}

API void *wamp_Info(WAMP *w)
// Returns the 'info' pointer previously set using wamp_SetInfo()
{
	return w ? w->info : NULL;
}

STATIC WAMP *wamp_New(const char *name)
// This function is used only by other wamp_NewXxx() functions.
// name must be on the heap
{
	WAMP *w = NEW(WAMP, 1);

	w->name = name;
	w->session = NULL;
	w->realm = NULL;
	w->handlers = idmap_New();
	w->info = NULL;
	w->cb_ondelete = NULL;
	w->deleting = 0;
	w->masked = 0;
	w->saveOutput = NULL;
	w->saveInput = NULL;

	if (!allWamps) allWamps = spmap_New();

	spmap_Add(allWamps, w->name, (void*)w);			// If it's already there then the world is probably already ending

	return w;
}

API HLIST *wamp_SaveOutput(WAMP *wamp, HLIST *hlist)
// Save a copy of all output from the WAMP in hlist.
// Returns the previous value
{
	HLIST *result = NULL;

	if (wamp) {
		result = wamp->saveOutput;
		wamp->saveOutput = hlist;
	}

	return result;
}

API HLIST *wamp_SaveInput(WAMP *wamp, HLIST *hlist)
// Save a copy of all input to the WAMP in hlist.
// Returns the previous value
{
	HLIST *result = NULL;

	if (wamp) {
		result = wamp->saveInput;
		wamp->saveInput = hlist;
	}

	return result;
}

API void wamp_SetMasked(WAMP *wamp, int masked)
{
	if (wamp)
		wamp->masked = masked;
}


API WAMP *wamp_NewPseudo(WAMPCB_Data fn, const char *name)
{
	WAMP *w = wamp_New(hprintf(NULL, "pseudo_%s", name));

	w->connectionType = WAMP_CONN_CODE;
	w->connection.fn = fn;

	return w;
}

STATIC void OnSocketDeleted(WS *ws)
{
	WAMP *wamp = ws_Info(ws);

//Log("WA: Socket belonging to %s (%s) being deleted", wamp_Name(wamp), ws_Name(ws));
	wamp_Delete(wamp);
//HERE!! - need to ensure the wamp is deleted and anything relying on it is removed from lists etc.
}

API WAMP *wamp_NewOnWebsocket(WS *ws, int masked)
{
	WAMP *w = wamp_New(hprintf(NULL, "wamp_%s", ws_Name(ws)));

	w->connectionType = WAMP_CONN_WEBSOCKET;
	w->connection.ws = ws;
	w->masked = masked;

	ws_SetInfo(ws, w);
//Log("WA: Setting UTF8 handler for %s at %p (wamp_HandleIncomingData)", ws_Name(ws), wamp_HandleIncomingData);
	ws_SetUtf8Handler(ws, wamp_HandleIncomingData);
	ws_OnDelete(ws, OnSocketDeleted);

	return w;
}

API WAMP *wamp_ByName(const char *name)
{
	return name ? (WAMP*)spmap_GetValue(allWamps, name) : NULL;
}

STATIC int wamp_Write(WAMP *wamp, const char *message)
// Write a string to this WAMP's output channel
// The string will always be ASCII (JSON) so we don't need a length
// Returns the number of bytes sent
{
	int result = 0;

	if (wamp && message) {
		if (wamp->connectionType == WAMP_CONN_WEBSOCKET) {	// Means it's a WebSocket, which is the only thing we know at the moment
			int fragLen;
			const char *frag = ws_MakeFragment(1, 1, wamp->masked ? -1 : 0, -1, message, &fragLen);

LogString(wamp, "WAMP OUT", message);
			result = ws_WriteHeap(wamp->connection.ws, fragLen, frag);
		} else if (wamp->connectionType == WAMP_CONN_RAWSOCKET) {		// Raw socket
		} else if (wamp->connectionType == WAMP_CONN_CODE) {			// Pseudo WAMP
			// We should never get here as this case is picked up in wamp_WriteJson()
		} else {										// TODO: An error really...
		}
		if (wamp->saveOutput) {
			hlist_Add(wamp->saveOutput, -1, message);
			hlist_Add(wamp->saveOutput, 1, "\n");
		}
	}

	return result;
}

STATIC int wamp_WriteHeap(WAMP *wamp, const char *message)
// Exactly like wamp_Write() but deletes the message afterwards
{
	int result = wamp_Write(wamp, message);
	szDelete(message);

	return result;
}

API void wamp_WriteJson(WAMP *wamp, JSON *json)
{
	const char *message = json_RenderHeap(json);
	if (message) {
//Log("WA: wamp_WriteJson(%p, %s)", wamp, message);
		if (wamp->connectionType == WAMP_CONN_CODE) {
			(wamp->connection.fn)(wamp, json);
			json_Delete(json);
		} else {
			wamp_WriteHeap(wamp, message);
		}
	} else {
		//Log("WA: Duff JSON passed to wamp_SendJson");
	}
}

API void wamp_WriteJsonHeap(WAMP *wamp, JSON *json)
{
	wamp_WriteJson(wamp, json);
	json_Delete(json);
}

API JSON *wamp_NewMessage(int type, long long id)
// Returns a new JSON array with the type filled in and the id if it's non-0
{
	JSON *j = json_NewArray();
	json_ArrayAddInteger(j, type);
	if (id) json_ArrayAddInteger(j, id);

	return j;
}

STATIC void AddArguments(JSON *json, JSON *argList, JSON *argDict)
// Add the argList and argDict to the message.
// Note that an empty argList array will be inserted if it is NULL and argDict is not.
// argList and argDict become owned by the message so don't go deleting them later.
{
	if (argDict && !argList) argList = json_NewArray();		// Need to make an argList if we don't have one, but have an argDict
	if (argList) json_ArrayAdd(json, argList);
	if (argDict) json_ArrayAdd(json, argDict);
}

API void wamp_SendError(WAMP *wamp, int type, long long id, SPMAP *details, const char *uri, JSON *argList, JSON *argDict)
// If details, argList and/or argDict are non-NULL, they become owned, then deleted here.
// Generic error sending
// wamp			- Where we're sending the error
// type			- E.g. WAMP_INVOCATION, WAMP_CALL etc.
// id			- The identifier which will (hopefully) allow the receipient to tie up the error with the message that caused it
// details		- NULL or a details MAP
// uri			- A WAMP error uri
// argList	- NULL or some JSON containing the argument list array
// argDict	- NULL or some JSON containing the argument list dictionary
{
	JSON *j = wamp_NewMessage(WAMP_ERROR, 0);
	json_ArrayAddInteger(j, type);
	json_ArrayAddInteger(j, id);
	JSON *callDetails = json_NewObjectWith(details);
	json_ArrayAdd(j, callDetails);
	json_ArrayAddStringz(j, uri);
	AddArguments(j, argList, argDict);

	wamp_WriteJsonHeap(wamp, j);
}

API void wamp_SendErrorStr(WAMP *wamp, int type, long long id, const char *err, const char *uri, JSON *argList, JSON *argDict)
// If argList and/or argDict are non-NULL, they become owned, then deleted here.
{
	SPMAP *details = spmap_New();
	spmap_Add(details, "error", json_NewStringz(err));

	wamp_SendError(wamp, type, id, details, uri, argList, argDict);
}

API void wamp_SendResult(WAMP *wamp, long long requestId, JSON *details, JSON *argList, JSON *argDict)
// If details, argList and/or argDict are non-NULL, they become owned, then deleted here.
{
	JSON *j = wamp_NewMessage(WAMP_RESULT, requestId);
	json_ArrayAdd(j, details ? details : json_NewObject());
	AddArguments(j, argList, argDict);

	wamp_WriteJsonHeap(wamp, j);
}

API void wamp_CloseAbort(WAMP *wamp, int type, const char *uri, const char *reason)
// Close and Abort formats are identical apart from the type
{
	JSON *j = wamp_NewMessage(type, 0);
	JSON *jreason = json_ArrayAdd(j, json_NewObject());
	if (reason)
		json_ObjectAddStringz(jreason, "reason", reason);
	json_ArrayAddStringz(j, uri);

	wamp_WriteJsonHeap(wamp, j);
}

API void wamp_Abort(WAMP *wamp, const char *uri, const char *reason)
{
	wamp_CloseAbort(wamp, WAMP_ABORT, uri, reason);
}

API void wamp_Close(WAMP *wamp, const char *uri, const char *reason)
// Sends a WAMP close message with the given reason
{
	wamp_CloseAbort(wamp, WAMP_GOODBYE, uri, reason);
}

API void wamp_Finish(WAMP *wamp)
// We have finished with this WAMP so close the associated channel and delete it.
{

}

STATIC SPMAP *realm_Map()
{
	static SPMAP *realm_map = NULL;

	if (!realm_map) {
		realm_map = spmap_New();

		WAMPREALM *r = NEW(WAMPREALM, 1);
		r->name = strdup("spider");
		r->calleeMapExact = NULL;
		r->calleeMapPrefix = NULL;
		r->calleeMapWildcard = NULL;
		r->redirect = idmap_New();
		r->subMapExact = NULL;
		r->subMapPrefix = NULL;
		r->subMapWildcard = NULL;
		r->allSubscriptions = NULL;

		r->wantForwardSubscriptions = 0;
		r->forwardSubscriptions = NULL;				// Reset forwarding
		r->fwdSubscriptionMap = ssmap_New();
		r->fwdUnsubscriptionMap = ssmap_New();
		r->fwdEventMap = ssmap_New();
		r->fwdPublishMap = ssmap_New();
		spmap_Add(realm_map, "spider", r);
	}

	return realm_map;
}

API int wamp_SetRealm(WAMP *w, const char *name)
{
	WAMPREALM *realm = (WAMPREALM*)spmap_GetValue(realm_Map(), name);
	if (realm) w->realm = realm;

	return !!realm;
}

STATIC WAMPREALM *wamp_RealmByName(const char *name)
{
	return (WAMPREALM*)spmap_GetValue(realm_Map(), "spider");				/// TODO: KLUDGE!!!
//	return (WAMPREALM*)spmap_GetValue(realm_Map(), name);
}

STATIC WAMPSESSION *wamp_NewSession(WAMPREALM *realm, long long id)
{
	WAMPSESSION *s = NEW(WAMPSESSION, 1);

	if (!id) id = wamp_RandomId();
	s->id = id;
	s->realm = realm;

	return s;
}

STATIC long long session_Id(WAMPSESSION *session)
{
	return session ? session->id : 0;
}

STATIC WAMPSESSION *wamp_GetSession(long long id)
{
	return NULL;
}

STATIC int wamp_Validate(WAMP *wamp, int type, JSON *json)
// Checks the validity of the message, sending an error back if there is a problem
// If there is a problem, an error will have been sent to 'wamp' before returning.
// Returns	0		Ok
//			1...	Problem
{
	int result = 0;

	typedef struct {
		int type;
		int min;
		int max;
		const char *signature;				// I=int, F=Float, N=number, B=bool, O=object, U=Uri, A=Array, S=String
	} valid_t;

	static valid_t valids[] = {
	//	Message type			min	max	Types
		{WAMP_HELLO,			3,	3,	"ISO"},
		{WAMP_WELCOME,			3,	3,	"IIO"},
		{WAMP_ABORT,			3,	3,	"IOU"},
		{WAMP_GOODBYE,			3,	3,	"IOU"},
		{WAMP_ERROR,			5,	7,	"IIIOUAO"},
		{WAMP_PUBLISH,			4,	6,	"IIOUAO"},
		{WAMP_PUBLISHED,		3,	3,	"III"},
		{WAMP_SUBSCRIBE,		4,	4,	"IIOU"},
		{WAMP_SUBSCRIBED,		3,	3,	"III"},
		{WAMP_UNSUBSCRIBE,		3,	3,	"III"},
		{WAMP_UNSUBSCRIBED,		2,	2,	"II"},
		{WAMP_EVENT,			4,	6,	"IIIOAO"},
		{WAMP_REGISTER,			4,	4,	"IIOU"},
		{WAMP_REGISTERED,		3,	3,	"III"},
		{WAMP_UNREGISTER,		3,	3,	"III"},
		{WAMP_UNREGISTERED,		2,	2,	"II"},

		{WAMP_CALL,				4,	6,	"IIOUAO"},
		{WAMP_INVOCATION,		4,	6,	"IIIOAO"},
		{WAMP_YIELD,			3,	5,	"IIOAO"},
		{WAMP_RESULT,			3,	5,	"IIOAO"},

		{0,0,0,0}
	};

	valid_t *v = valids;
	while (v->type) {
		if (v->type == type) {
			int argc = json_ArrayCount(json);

			if (argc < v->min || argc > v->max) {
				const char *msg;

				if (v->min == v->max) {
					msg = hprintf(NULL, "A %s message must have %d elements", wamp_TypeName(type), v->min);
				} else {
					msg = hprintf(NULL, "A %s message must have %d-%d elements", wamp_TypeName(type), v->min, v->max);
				}
				wamp_SendErrorStr(wamp, 0, 0, msg, ErrInvalidArgument, NULL, NULL);
				szDelete(msg);
				result = 1;
				break;
			}

			int i=0;
			const char *expected = NULL;
			for (i=0;i<argc;i++) {
				char check = v->signature[i];
				char actual = json_Type(json_ArrayAt(json, i));

				if (check == 'I' && actual != JSON_INTEGER) {
					expected = "INTEGER";
				} else if (check == 'N' && actual != JSON_FLOAT && actual != JSON_INTEGER) {
					expected = "NUMBER";
				} else if (check == 'B' && actual != JSON_BOOL) {
					expected = "true or false";
				} else if (check == 'O' && actual != JSON_OBJECT) {
					expected = "object";
				} else if (check == 'A' && actual != JSON_ARRAY) {
					expected = "array";
				} else if (check == 'U' && actual != JSON_STRING) {
					expected = "URI";
				} else if (check == 'S' && actual != JSON_STRING) {
					expected = "string";
				}

				if (expected) {
					const char *found = "something else";
					if (actual == JSON_INTEGER)	found = "integer";
					else if (actual == JSON_FLOAT) found = "float";
					else if (actual == JSON_BOOL) found = "boolean";
					else if (actual == JSON_NULL) found = "null";
					else if (actual == JSON_OBJECT) found = "object";
					else if (actual == JSON_ARRAY) found = "array";
					else if (actual == JSON_STRING) found = "string";

					const char *msg = hprintf(NULL, "Message type %d (%s), element %d should be %s not %s", type, wamp_TypeName(type), i+1, expected, found);
					wamp_SendErrorStr(wamp, 0, 0, msg, ErrInvalidArgument, NULL, NULL);
					szDelete(msg);
					result = 2;
					break;
				}
			}

			break;
		}
		v++;
	}

	return result;
}

API void wamp_CallbackNoCallee(WAMPCB_NoCallee cb)
{
	wampcb_NoCallee = cb;
}

API WAMPCB_DeleteCallback wamp_OnDelete(WAMP *w, WAMPCB_DeleteCallback cb)
{
	WAMPCB_DeleteCallback previous = NULL;

	if (w) {
		previous = w->cb_ondelete;
		w->cb_ondelete = cb;
	}

	return previous;
}

API void wamp_RegisterInvokee(WAMPCB_Invokee cb)
{
	wampcb_Invokee = cb;
}

char *mystrtok_r(char *s, char c, char **next)
// strtok_r doesn't seem to want to return empty components and we need that functionality
// It's slightly different as 's2' is actually just a char as that's all I need
{
	char *result = s;
	if (!result) result = *next;
	if (result) {
		char *end = strchr(result, c);

		if (end) *end++ = '\0';
		*next = end;
	}

	return result;
}

STATIC int wamp_WildcardMatch(const char *wildcard, const char *match)
// Taking a wildcard such as mtxml..thing and a match such as mtxml.specific.thing, returns 1 for a match or 0 for not
{
	int matched = 1;

	char *next1;
	char *next2;

	char *wildcardCopy = strdup(wildcard);
	char *matchCopy = strdup(match);
	char *w = wildcardCopy;
	char *m = matchCopy;
	for (;;) {
		const char *wildcardComponent = mystrtok_r(w, '.', &next1);
		const char *matchComponent = mystrtok_r(m, '.', &next2);

		if (!wildcardComponent && !matchComponent)									// We've matched
			break;

		if (!wildcardComponent || !matchComponent) {								// One has ended early
			matched = 0;
			break;
		}

		if (*wildcardComponent && strcmp(wildcardComponent, matchComponent)) {		// A component differs
			matched = 0;
			break;
		}

		w = NULL;
		m = NULL;
	}

	free(wildcardCopy);
	free(matchCopy);

	return matched;
}

STATIC int wamp_AddCaller(const char *callerWampName, long long callerRequestId, const char *calleeWampName, long long calleeRequestId, wamp_invokee_t *invokee)
// Adds a caller to those currently known.
//
// callerWampName	- WAMP name of the caller
// callerRequestId	- request ID passed by the caller
// calleeWampName	- WAMP name of the callee
// calleeRequestId	- request ID passed to the callee
// invokee			- Invokee information (wamp_invokee_t)
//
// Returns	0	Ok
//			1	requestId was already known
{
	if (!activeCallMap)
		activeCallMap = idmap_New();

	wamp_call_t *callInfo = idmap_GetValue(activeCallMap, calleeRequestId);

	if (callInfo)
		return 1;

	callInfo = NEW(wamp_call_t, 1);
	callInfo->callerWampName = strdup(callerWampName);
	callInfo->callerRequestId = callerRequestId;
	callInfo->calleeWampName = strdup(calleeWampName);
	callInfo->calleeRequestId = calleeRequestId;
	callInfo->invokee = invokee;

	idmap_Add(activeCallMap, calleeRequestId, callInfo);

	return 0;
}

STATIC void wamp_DeleteCallInfo(wamp_call_t *callInfo)
// Safely deletes an active call info structure
{
	if (callInfo) {
		idmap_DeleteKey(activeCallMap, callInfo->calleeRequestId);

		szDelete(callInfo->callerWampName);
		szDelete(callInfo->calleeWampName);

		free((char*)callInfo);
	}
}

STATIC void wamp_CallWampGone(const char *wampName)
// A wamp has gone away (been deleted, channel gone etc.) so we need to tidy up the caller information for any current
// calls where this wamp is either the caller or callee.
{
//Log("Checking for %s existing in activeCallMap (%p)", wampName, activeCallMap);
	if (activeCallMap && wampName) {
		idmap_Reset(activeCallMap);
		long long calleeRequestId;
		wamp_call_t *callInfo;

		while (idmap_GetNextEntry(activeCallMap, &calleeRequestId, (void**)&callInfo)) {
			if (!strcmp(callInfo->callerWampName, wampName)) {				// Caller has gone - do we inform the callee somehow?
//Log("Caller '%s' has gone", wampName);
				if (!strcmp(callInfo->calleeWampName, wampName)) {			// Both have gone (call was back to itself)
//Log("Caller/callee '%s' has gone", wampName);
				}
				wamp_DeleteCallInfo(callInfo);
			} else if (!strcmp(callInfo->calleeWampName, wampName)) {		// Callee has gone - send error to caller
				WAMP *caller = wamp_ByName(callInfo->callerWampName);

				if (caller) {
					wamp_SendErrorStr(caller, WAMP_CALL, callInfo->callerRequestId, "Callee has gone away", "wamp.error.call.failed", NULL, NULL);
				}
				wamp_DeleteCallInfo(callInfo);
			}
		}
	}
}

STATIC const char *wamp_FindAndRemoveCaller(long long requestId, long long *pcallerRequestId)
// Finds the callee information in the active call map and returns the caller ID, removing the information at the same time.
// Returns a copy of the caller Wamp name on the heap
// If pcallerRequestId is Non-NULL, it receives a copy of the callerRequestID
{
	const char *result = NULL;

	if (activeCallMap) {
		wamp_call_t *callInfo = idmap_GetValue(activeCallMap, requestId);

		if (callInfo) {
			result = strdup(callInfo->callerWampName);
			if (pcallerRequestId)
				*pcallerRequestId = callInfo->callerRequestId;

			wamp_DeleteCallInfo(callInfo);
		}
	}

	return result;
}

STATIC void wamp_RemoveInvokee(WAMP *wamp, wamp_callee_t *callee, int index)
// Removes the indexed invokee from the callee structure
// NB. The callee may be deleted by this call!
{
	if (!wamp || !callee || index < 0 || index >= callee->nInvokees)
		return;

	WAMPREALM *realm = wamp->realm;
	long long registrationId = callee->registrationId;
	long long sessionId = wamp->session->id;

	JSON *publishArgs = json_NewObject();
	json_ObjectAddStringz(publishArgs, "uri", callee->procedure);
	json_ObjectAddInteger(publishArgs, "session", wamp->session->id);
	json_ObjectAddInteger(publishArgs, "registration", registrationId);
	wamp_Publish(wamp, "wamp.registration.on_unregister", NULL, NULL, publishArgs);

//Log("Removing invokee %d for %s", index, callee->procedure);
	if (index < callee->nInvokees-1) {
		memmove(callee->invokee+index+1, callee->invokee+index, (callee->nInvokees-1-index)*sizeof(*callee->invokee));
	}
	callee->nInvokees--;

	if (callee->nInvokees) {
		// Reset the highest priority
		int highestPriority = INT_MIN;
		int i;
		for (i=0;i<callee->nInvokees;i++) {
			if (callee->invokee[i]->priority > highestPriority)
				highestPriority = callee->invokee[i]->priority;
		}
		callee->highestPriority = highestPriority;
	} else {												// No invokees so we want to forget the procedure completely
		// Look for the callee in the three maps
		const char *procedure = callee->procedure;
		SPMAP *map = NULL;

		wamp_callee_t *t = NULL;

		if (!map && realm->calleeMapExact) {
			if (callee == spmap_GetValue(realm->calleeMapExact, procedure))
				map = realm->calleeMapExact;
		}
		if (!map && realm->calleeMapPrefix) {
			if (callee == spmap_GetValue(realm->calleeMapPrefix, procedure))
				map = realm->calleeMapPrefix;
		}
		if (!map && realm->calleeMapWildcard) {
			if (callee == spmap_GetValue(realm->calleeMapWildcard, procedure))
				map = realm->calleeMapWildcard;
		}

		JSON *publishArgs = json_NewObject();
		json_ObjectAddStringz(publishArgs, "uri", procedure);
		json_ObjectAddInteger(publishArgs, "session", wamp->session->id);
		json_ObjectAddInteger(publishArgs, "registration", registrationId);
		wamp_Publish(wamp, "wamp.registration.on_delete", NULL, NULL, publishArgs);

		// At this point, we should have the map set correctly
		if (map) {
			spmap_DeleteKey(map, procedure);

			szDelete(callee->procedure);
			free((char*)callee);
		}
	}
}

STATIC int wamp_Unregister(WAMP *wamp, long long registrationId)
// Removes any callee registration with the given ID for the wamp
// Returns 1 if the subscription was removed, 0 if it wasn't there
{
	int done = 0;

	if (wamp) {
		WAMPREALM *realm = wamp->realm;

		SPMAP *maps[WAMP_CALLTYPE_COUNT];
		maps[WAMP_CALLTYPE_EXACT] = realm->calleeMapExact;
		maps[WAMP_CALLTYPE_PREFIX] = realm->calleeMapPrefix;
		maps[WAMP_CALLTYPE_WILDCARD] = realm->calleeMapWildcard;

Log("Unregistering %Ld from %s", registrationId, wamp->name);
		int i;
		for (i=0; i<3; i++) {
			SPMAP *map = maps[i];

			if (map) {
				const char *name;
				wamp_callee_t *callee;
				spmap_Reset(map);
				while(!done && spmap_GetNextEntry(map, &name, (void**)&callee)) {
					int j;

					if (callee->registrationId == registrationId) {
						for (j=0;j<callee->nInvokees;j++) {
							wamp_invokee_t *invokee = callee->invokee[i];

							if (!strcmp(invokee->wampName, wamp->name)) {

								wamp_RemoveInvokee(wamp, callee, j);
								done = 1;
								break;
							}
						}
					}
				}
			}
		}
	}

	return done;
}

STATIC void wamp_RemoveFromCalleeMap(WAMP *wamp, SPMAP *map)
// If the wamp appears as the value in the map passed, remove it.
{
//Log("Looking for %s in map %p", wamp->name, map);
	if (wamp && map) {
		const char *name;
		wamp_callee_t *callee;

		// Keep looking for registration IDs that belong to this caller and remove them.
		int foundRegistrationId = 1;					// Pretend we've found one to start the loop off
		while (foundRegistrationId) {
			foundRegistrationId = 0;
			spmap_Reset(map);
			while(spmap_GetNextEntry(map, &name, (void**)&callee)) {
				int i;

				for (i=0;i<callee->nInvokees;i++) {
					wamp_invokee_t *invokee = callee->invokee[i];
					if (!strcmp(wamp->name, invokee->wampName)) {
						wamp_RemoveInvokee(wamp, callee, i);
						foundRegistrationId=1;
						break;
					}
				}
			}
		}
	}
}

STATIC void wamp_RemoveSubscription(WAMP *wamp, subscription_t *sub)
{
	if (wamp && sub) {
		spmap_DeleteKey(sub->wamps, wamp->name);

		if (!spmap_Count(sub->wamps)) {						// Deleted last subscriber
			spmap_Delete(sub->wamps);
			sub->wamps = NULL;								// This ensures it gets deleted by the caller
		}
	}
}

STATIC void wamp_RemoveFromSubscribeeMap(WAMP *wamp, SPMAP *map)
{
	if (wamp && map) {
		const char *wampName = wamp->name;
		const char *name;
		subscription_t *sub;
		SSET *set = sset_New();									// Names of any subscriptions that are no longer subscribed to

		spmap_Reset(map);
		while(spmap_GetNextEntry(map, &name, (void*)&sub)) {	// Find each subscription
			wamp_RemoveSubscription(wamp, sub);					// Remove this wamp if it's there

			if (!sub->wamps) {
				sset_Add(set, name);							// There are no wamps left in this subscription
				idmap_DeleteKey(wamp->realm->allSubscriptions, sub->subscriptionId);	// Remove it from the map of all subscriptions
			}
		}

		while (sset_GetNextEntry(set, &name)) {					// Go through and delete any empty subscriptions
//Log("WA: Removing subscribee %s from map", name);
			spmap_DeleteKey(map, name);
		}
		sset_Delete(set);
	}
}

STATIC void wamp_RemoveFromMaps(WAMP *wamp)
// Removes the wamp from any callee or subscription maps that it's in
{
	if (wamp) {
//Log("Removing %s from maps", wamp->name);
		if (wamp->realm) {
			WAMPREALM *realm = wamp->realm;

			// Callees is quite straightforward, look for it in each of the three maps and delete any found
			wamp_RemoveFromCalleeMap(wamp, realm->calleeMapExact);
			wamp_RemoveFromCalleeMap(wamp, realm->calleeMapPrefix);
			wamp_RemoveFromCalleeMap(wamp, realm->calleeMapWildcard);

			// Subscribers is a little more painful as it appears deeper within the sructures

			wamp_RemoveFromSubscribeeMap(wamp, realm->subMapExact);
			wamp_RemoveFromSubscribeeMap(wamp, realm->subMapPrefix);
			wamp_RemoveFromSubscribeeMap(wamp, realm->subMapWildcard);
		}

		wamp_CallWampGone(wamp->name);							// Remove from any active calls
	}
}

STATIC wamp_callee_t *wamp_FindCallee(WAMP *wamp, const char *procedure)
{
//Log("WA: wamp_FindCallee(%p, '%s')", wamp, procedure);
	wamp_callee_t *result = NULL;
	WAMPREALM *realm = wamp->realm;

	if (realm->calleeMapExact) {												// Check for an exact match
		result = (wamp_callee_t*)spmap_GetValue(realm->calleeMapExact, procedure);
	}

	if (!result && realm->calleeMapPrefix) {									// Not found, Check for a prefix match
		const char *name;
		void *value;

//Log("WA: Looking for prefix...");
		spmap_Reset(realm->calleeMapPrefix);
		while(spmap_GetNextEntry(realm->calleeMapPrefix, &name, &value)) {
			if (!strncmp(procedure, name, strlen(name))) {
//Log("Checked '%s' against '%s' (%d)", procedure, name, strlen(name));
				result = (wamp_callee_t*)value;
				break;
			}
		}
	}

	if (!result && realm->calleeMapWildcard) {									// Not found, Check for a wildcard match
		const char *name;
		void *value;

		spmap_Reset(realm->calleeMapWildcard);
		while(spmap_GetNextEntry(realm->calleeMapWildcard, &name, &value)) {
			if (wamp_WildcardMatch(procedure, name)) {
				result = (wamp_callee_t*)value;
				break;
			}
		}
	}

	if (!result && wampcb_NoCallee) {
		int whatToDo = (*wampcb_NoCallee)(procedure);							// Give the callback chance to register one
//Log("WA: NO-CALLEE returned %d", whatToDo);

		if (whatToDo) {															// It says it might work if you try again
			WAMPCB_NoCallee temp = wampcb_NoCallee;								// Stop us repeatedly calling
			wampcb_NoCallee = NULL;

//Log("WA: trying to find callee for %s again", procedure);
			result = wamp_FindCallee(wamp, procedure);							// Try again
//Log("WA: Second attempt at finding callee = %d", result);

			wampcb_NoCallee = temp;
		}
	}

	return result;
}

STATIC wamp_invokee_t *wamp_FindInvokee(WAMP *wamp, const char *procedure, long long *registrationIdp)
// Returns an invokee given the requested call.  This takes into account the invocation policy (roundrobin etc.)
{
	wamp_callee_t *callee = wamp_FindCallee(wamp, procedure);

	if (!callee) return NULL;							// A procedure has not been registered for this at all

	long long registrationId = callee->registrationId;
	int highestPriority = callee->highestPriority;		// We only want something matching this
	int nInvokees = callee->nInvokees;
	int breakPlease = 0;								// Logic says to stop looking
	int roundRobinCount = callee->roundRobinCount;		// The current robin
	int randomCount = 0;								// The number of possibilities
	int i;
	wamp_invokee_t *firstInvokee = NULL;				// Used in round-robin logic

	wamp_invokee_t *invokee = NULL;						// This will be the one we eventually pick

	for (i=0; i<nInvokees; i++) {
		wamp_invokee_t *thisInvokee = callee->invokee[i];
		if (thisInvokee->priority != highestPriority)
			continue;

		invokee=thisInvokee;							// Potentially the one we want

		switch (callee->invokePolicy) {
			case WAMP_INVOKE_SINGLE:						// Take the only one we'll find
				breakPlease = 1;
				break;
			case WAMP_INVOKE_ROUNDROBIN:
				roundRobinCount--;
				if (roundRobinCount == 0) {				// We've found the one we want
					breakPlease = 1;
					break;
				}
				if (!firstInvokee) firstInvokee=invokee;	// In case we wrap around
				break;
			case WAMP_INVOKE_RANDOM:
				randomCount++;
				break;
			case WAMP_INVOKE_FIRST:						// We want the first we find
				breakPlease = 1;
				break;
			case WAMP_INVOKE_LAST:						// Keep going, we'll take the last we found
				break;
		}
		if (breakPlease)
			break;
	}

	if (callee->invokePolicy == WAMP_INVOKE_ROUNDROBIN) {
		if (roundRobinCount) {							// Didn't find one
			invokee = firstInvokee;
			callee->roundRobinCount = 1;
		}
		callee->roundRobinCount++;
	} else if (callee->invokePolicy == WAMP_INVOKE_RANDOM) {
		if (randomCount) {
			long choice = ((mrand48() & 0xffff) * randomCount) >> 16;		// Random(0..randomCount)
//Log("WA: Have invokees(%d), chosen %d", randomCount, choice+1);

			for (i=0; i<nInvokees; i++) {
				invokee = callee->invokee[i];

				if (invokee->priority == highestPriority) {
					if (!choice)
						break;
					choice--;
				}
			}
		}
	}

	if (invokee && registrationIdp) *registrationIdp = registrationId;

	return invokee;
}

STATIC void wamp_NoInvokee(WAMP *wamp, long long requestId, const char *procedure, JSON *list, JSON *dict)
// Called when we've been invoked but we haven't a function registered to handle it
{
	wamp_SendError(wamp, WAMP_INVOCATION, requestId, NULL, "error.no_such_procedure", list, dict);
//	JSON *invErr = json_NewArray();
//	json_ArrayAddInteger(invErr, WAMP_ERROR);
//	json_ArrayAddInteger(invErr, WAMP_INVOCATION);
//	json_ArrayAddInteger(invErr, requestId);
//	JSON *err = json_NewArray();
//	json_ArrayAddStringz(err, "callee is unable to handle anything");
//	json_ArrayAdd(invErr, err);

//	wamp_WriteJsonHeap(wamp, invErr);
}

API void wamp_Delete(WAMP *w)
{
	if (w) {
Log("WA: Deleting %s (%d)", w->name, w->deleting);
		if (w->deleting) return;
		w->deleting = 1;

		if (w->cb_ondelete)
			(w->cb_ondelete)(w);

		wamp_RemoveFromMaps(w);
//HERE
		switch (w->connectionType) {
			case WAMP_CONN_WEBSOCKET:							// Websocket
				ws_Delete(w->connection.ws);
				break;
			case WAMP_CONN_RAWSOCKET:							// Rawsocket
				break;
			case WAMP_CONN_CODE:								// Code
				break;
		}

		if (w->name)
			spmap_DeleteKey(allWamps, w->name);

		idmap_Delete(w->handlers);
		szDelete(w->name);
		free((char*)w);
	}
}

API int wamp_Hello(WAMP *wamp, const char *realm, JSON *opts)
// Does the work of 'helloing' a wamp connection, which is useful if we want to create an already registered
// channel.  E.g. Connecting a legacy API handler.
// Returns	0	Everything went swimmingly
//			1	Was already in a realm
//			2	Realm didn't accept the connection (no such realm)
//			3	Was already in a session
{
	if (wamp->realm) return 1;
	wamp->realm = wamp_RealmByName(realm);
	if (!wamp->realm) return 2;

	if (wamp->session) return 3;

	wamp->session = wamp_NewSession(wamp->realm, 0);
	long long id = session_Id(wamp->session);
}

STATIC int wamp_MatchType(const char *match)
// returns	WAMP_CALLTYPE_EXACT		match == "exact"
// returns	WAMP_CALLTYPE_PREFIX	match == "prefix"
// returns	WAMP_CALLTYPE_WILDCARD	match == "wildcard"
// returns	0	anything else
{
	int result = 0;

	if (match) {
		if (!strcmp(match, "exact"))			{ result = WAMP_CALLTYPE_EXACT;
		} else if (!strcmp(match, "prefix"))	{ result = WAMP_CALLTYPE_PREFIX;
		} else if (!strcmp(match, "wildcard"))	{ result = WAMP_CALLTYPE_WILDCARD;
		}
	}

	return result;
}

STATIC wamp_callee_t *wamp_FindCalleeForType(WAMPREALM *realm, int matchType, const char *procedure, SPMAP **pmap)
// Looks for a callee for the match type (1..3) and procedure name.
// *pmap gets a spmap*, which will always be set to a valid map unless we're returning NULL
// Returns	NULL			The procedure isn't registered (under this type)
//			wamp_callee_t*	A Pointer to the relevant callee structure
{
	wamp_callee_t *result = NULL;

	if (realm && procedure) {
		SPMAP **my_pmap = NULL;

		switch (matchType) {
			case WAMP_CALLTYPE_EXACT:		my_pmap = &realm->calleeMapExact;		break;
			case WAMP_CALLTYPE_PREFIX:		my_pmap = &realm->calleeMapPrefix;		break;
			case WAMP_CALLTYPE_WILDCARD:	my_pmap = &realm->calleeMapWildcard;	break;
		}

		if (my_pmap) {
			if (!*my_pmap)
				*my_pmap = spmap_New();

			result = (wamp_callee_t*)spmap_GetValue(*my_pmap, procedure);
			if (pmap) *pmap = *my_pmap;
		}
	}

	return result;
}

STATIC const char *wamp_RegisterAnyCallee(WAMPREALM *realm, WAMP *wamp, const char *match, const char *invoke, long long priority, const char *procedure, WAMPCB_Invokee invokee, long long *registrationIdp)
// To register an internal invokee...
// realm		realm as named in calling wamp_RegisterInternalCallee()
// wamp			NULL
// match		"exact", "prefix" or "wildcard"
// invoke		"single", "roundrobin", "random", "first" or "last"
// priority		-INF .. 0 .. +INF
// procedure	Named procedure (or prefix etc)
// invokee		Callback procedure to handle
//
// To register an invokee on a WAMP
// realm		realm from the wamp
// wamp			The wamp as registered
// match		"exact", "prefix" or "wildcard"
// invoke		"single", "roundrobin", "random", "first" or "last"
// priority		-INF .. 0 .. +INF
// procedure	NULL
// invokee		Callback procedure to handle
//
// Returns	NULL	All OK
//			char*	Error message (treat as static)

{
//Log("WA: wamp_RegisterAnyCallee(%p, %p, %s, %s, %Ld, %s, %p, %p)", realm, wamp, match, invoke, priority, procedure, invokee,  registrationIdp);
	if (!realm) return "Realm not known";

	int invokePolicy = 0;
	if (!strcmp(invoke, "single"))
		invokePolicy = WAMP_INVOKE_SINGLE;
	else if (!strcmp(invoke, "roundrobin"))
		invokePolicy = WAMP_INVOKE_ROUNDROBIN;
	else if (!strcmp(invoke, "random"))
		invokePolicy = WAMP_INVOKE_RANDOM;
	else if (!strcmp(invoke, "first"))
		invokePolicy = WAMP_INVOKE_FIRST;
	else if (!strcmp(invoke, "last"))
		invokePolicy = WAMP_INVOKE_LAST;
	else {
		return "Invoke type not known (must be \"single\", \"roundrobin\", \"random\", \"first\" or \"last\"";
	}

	int matchType = wamp_MatchType(match);
	if (!matchType)
		return "Match type not known (must be \"exact\", \"prefix\" or \"wildcard\")";

	SPMAP *map;
	wamp_callee_t *callee = wamp_FindCalleeForType(realm, matchType, procedure, &map);

	if (invokePolicy == WAMP_INVOKE_SINGLE && callee != NULL)		// Policy is single, but we've already got one
		return "Invoke type is \"single\" and the procedure is already registered";

	long long registrationId = wamp_RandomId();
	if (!callee) {													// Not had registration for this before
		callee = NEW(wamp_callee_t, 1);
		callee->procedure = strdup(procedure);						// So we can find the map entry for deletion
		callee->nInvokees = 0;
		callee->invokePolicy = invokePolicy;
		callee->highestPriority = priority;
		callee->invokee = NEW(wamp_invokee_t *, 1);
		callee->roundRobinCount = 1;
		callee->registrationId = registrationId;

		spmap_Add(map, procedure, (void*)callee);					// Add it so we'll find it next time

		JSON *publishArgs = json_NewObject();

		JSON *registrationDetails = json_NewObject();
		json_ObjectAddInteger(registrationDetails, "id", registrationId);
		json_ObjectAddStringz(registrationDetails, "created", TimeNow());
		json_ObjectAddStringz(registrationDetails, "uri", procedure);
		json_ObjectAddStringz(registrationDetails, "match", match);
		json_ObjectAddStringz(registrationDetails, "invoke", invoke);

		json_ObjectAddInteger(publishArgs, "session", wamp->session->id);
		json_ObjectAdd(publishArgs, "registrationDetails", registrationDetails);
		wamp_Publish(wamp, "wamp.registration.on_create", NULL, NULL, publishArgs);
	} else {
		if (callee->invokePolicy != invokePolicy) {
			return "Invokation policy does not match that of the existing registration";
		}
	}

	if (priority > callee->highestPriority)
		callee->highestPriority=priority;

	wamp_invokee_t *invokeeInfo = NEW(wamp_invokee_t, 1);			// Invokee specific information
	invokeeInfo->priority = priority;
	invokeeInfo->wampName = strdup(wamp_Name(wamp));;
	invokeeInfo->cb_invokee = invokee;

	RENEW(callee->invokee, wamp_invokee_t*, ++callee->nInvokees);	// Add to our list
	callee->invokee[callee->nInvokees-1] = invokeeInfo;

	if (registrationIdp) *registrationIdp = registrationId;

	return NULL;
}

API const char *wamp_RegisterWampCallee(WAMP *wamp, const char *match, const char *invoke, long long priority, const char *procedure, long long *registrationIdp)
{
	return wamp_RegisterAnyCallee(wamp->realm, wamp, match, invoke, priority, procedure, NULL, registrationIdp);
}

API const char *wamp_RegisterInternalCallee(const char *realmName, const char *match, const char *procedure, WAMPCB_Invokee invokee, long long *registrationIdp)
// Registers an internal invokee for a realm
// Returns		NULL	All went OK
//				char*	Error message (treat as static)
{
	WAMPREALM *realm = wamp_RealmByName(realmName);

	return wamp_RegisterAnyCallee(realm, NULL, match, "single", 0, procedure, invokee, registrationIdp);
}

API void wamp_RegisterRedirect(const char *realmName, int type, WAMPCB_Handler fn)
// Sets a function that will be called for all messages of the type given for the given realm.
// If the function returns -1, the normal processing will be performed instead.
// Any other value will be returned as the result of wamp_Dispatch() - 0=ok, 1...=error
{
	WAMPREALM *realm = wamp_RealmByName(realmName);

	if (realm) {
//Log("WA: Adding %p as handler for %s on \"%s\" (%p)", fn, wamp_TypeName(type), realmName, realm);
		idmap_Add(realm->redirect, (long long)type, (void*)fn);
	}
}

API void wamp_RegisterHandler(WAMP *wamp, int type, WAMPCB_Handler fn)
{
	idmap_Add(wamp->handlers, (long long)type, (void*)fn);
}

API void wamp_Ping(WAMP *wamp, int len, const char *data)
{
	if (wamp->connectionType == WAMP_CONN_WEBSOCKET)			// Only know how to ping if we are connected via a websocket
		ws_Ping(wamp->connection.ws, len, data);
}

API void wamp_Pong(WAMP *wamp, int len, const char *data)
{
	if (wamp->connectionType == WAMP_CONN_WEBSOCKET)			// Only know how to pong if we are connected via a websocket
		ws_Pong(wamp->connection.ws, len, data);
}

int wamp_HandleHello(WAMP *wamp, JSON *json)
// [2,1003687871946124,{
//		"roles":{
//			"dealer":{"features":{
//				"pattern_based_registration":true,
//				"shared_registration":true,
//				"caller_identification":true,
//				"progressive_call_results":true
//			}},
//			"broker":{"features":{
//				"publisher_identification":true,
//				"pattern_based_subscription":true,
//				"publisher_exclusion":true,
//				"subscriber_blackwhite_listing":true
//			}}
//		}
//	}
// ]
{
	const char *realmName = json_ArrayStringzAt(json, 1);
	JSON *opts = json_ArrayAt(json, 2);

	int err = wamp_Hello(wamp, realmName, opts);
	switch (err) {
		case 1:					// Already in a realm (these two should always be the same)
		case 3:					// Already in a session
			wamp_Abort(wamp, ErrInvalidArgument, "WAMP HELLO received within a session");
			return 1;
		case 2:
			wamp_Abort(wamp, "wamp.error.no_such_realm", "I can only accept \"spider\" currently");
			return 2;
	}

	long long id = session_Id(wamp->session);

	WAMPREALM *realm = wamp->realm;
	int canDealer = 1;
	int canBroker = !realm->wantForwardSubscriptions || (realm->wantForwardSubscriptions && realm->forwardSubscriptions);

	JSON *jResponse = wamp_NewMessage(WAMP_WELCOME, id);
	JSON *replyOpts = json_NewObject();
//	json_ObjectAddStringz(replyOpts, "agent", "MTWAMP");
	JSON *jRoles = json_NewObject();
	if (canDealer) {
		JSON *jObj = json_ObjectAdd(jRoles, "dealer", json_NewObject());
		JSON *jFeatures = json_ObjectAdd(jObj, "features", json_NewObject());
		json_ObjectAdd(jFeatures, "pattern_based_registration", json_NewBool(1));
		json_ObjectAdd(jFeatures, "shared_registration", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "caller_identification", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "progressive_call_results", json_NewBool(1));
	}
	if (canBroker) {
		JSON *jObj = json_ObjectAdd(jRoles, "broker", json_NewObject());
		JSON *jFeatures = json_ObjectAdd(jObj, "features", json_NewObject());
//		json_ObjectAdd(jFeatures, "publisher_identification", json_NewBool(1));
		json_ObjectAdd(jFeatures, "pattern_based_subscription", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "publisher_exclusion", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "subscriber_blackwhite_listing", json_NewBool(1));
	}
	json_ObjectAdd(replyOpts, "roles", jRoles);

	json_ObjectAddStringz(replyOpts, "realm", realmName);
	json_ObjectAddStringz(replyOpts, "authrole", "public");
	json_ObjectAddStringz(replyOpts, "authprovider", "static");
	json_ObjectAddStringz(replyOpts, "authmethod", "anonymous");
	json_ObjectAddStringz(replyOpts, "authid", "FE5F-CWWN-736S-53RX-M7U6-J7LL");

	json_ArrayAdd(jResponse, replyOpts);

	wamp_WriteJsonHeap(wamp, jResponse);

//	wamp_Pong(wamp, -1, "Ponging");			// Was hoping this might kick C# client into life

	return 0;
}

STATIC int wamp_HandleWelcome(WAMP *wamp, JSON *json)
{
	wamp->session = wamp_NewSession(wamp->realm, json_ArrayIntegerAt(json, 1));

	return 0;
}

STATIC int wamp_HandleGoodbye(WAMP *wamp, JSON *json)
{
	const char *uri = json_ArrayStringzAt(json, 2);

	if (strcmp(uri, ErrGoodbyeAndOut)) {					// Don't respond if they're saying 'goodbye and out'
		wamp_Close(wamp, ErrGoodbyeAndOut, NULL);
	}
	return 0;
}

STATIC int wamp_HandleError(WAMP *wamp, JSON *json)
{
	long long errorNumber = json_ArrayIntegerAt(json, 1);

	if (errorNumber == WAMP_INVOCATION) {					// An invocation error, need to pass back to the caller
		WAMP *callerWamp = NULL;

		long long requestId = json_ArrayIntegerAt(json, 2);
		long long callerRequestId;
		const char *callerName = wamp_FindAndRemoveCaller(requestId, &callerRequestId);

		if (callerName) {									// Should always find one
			callerWamp = wamp_ByName(callerName);			// May not find one if the wamp has 'gone away' since the call

			szDelete(callerName);
		}

		if (callerWamp) {									// The caller still exists
			SPMAP *details = json_ArrayTakeObjectAt(json, 3);
			const char *uri = json_ArrayStringzAt(json, 3);
			JSON *resultList = json_ArrayTakeAt(json, 4);
			JSON *resultDict = json_ArrayTakeAt(json, 4);

			wamp_SendError(callerWamp, WAMP_CALL, callerRequestId, details, uri, resultList, resultDict);
		}

		return 0;
	}

Log("WA: We've received an error message that nobody will handle: %s", json_Render(json));
	return 0;
}

STATIC int wamp_HandleRegister(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *procedure = json_ArrayStringzAt(json, 3);

	const char *match = "exact";
	JSON *jMatch = (JSON*)spmap_GetValue(options, "match");
	if (jMatch) {
		if (!json_IsString(jMatch)) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "Match value must be a string", "wamp.error.cannot_register", NULL, NULL);
			return 1;
		}
		match = json_AsStringz(jMatch);
	}

	const char *invoke = "single";
	JSON *jInvoke = (JSON*)spmap_GetValue(options, "invoke");
	if (jInvoke) {
		if (!json_IsString(jInvoke)) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "Invoke value must be a string", "wamp.error.cannot_register", NULL, NULL);
			return 1;
		}
		invoke = json_AsStringz(jInvoke);
	}

	long long priority = 0;
	JSON *jPriority = (JSON*)spmap_GetValue(options, "priority");
	if (jPriority) {
		if (!json_IsInteger(jPriority)) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "Priority value must be an integer", "wamp.error.cannot_register", NULL, NULL);
			return 1;
		}
		priority = json_AsInteger(jPriority);
	}

	long long registrationId;
	const char *err = wamp_RegisterWampCallee(wamp, match, invoke, priority, procedure, &registrationId);
	if (err) {
		wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, err, "wamp.error.cannot_register", NULL, NULL);
		return 1;
	}

	JSON *j = wamp_NewMessage(WAMP_REGISTERED, requestId);
	json_ArrayAddInteger(j, registrationId);

	wamp_WriteJsonHeap(wamp, j);

	JSON *publishArgs = json_NewObject();
	json_ObjectAddStringz(publishArgs, "uri", procedure);
	json_ObjectAddInteger(publishArgs, "session", wamp->session->id);
	json_ObjectAddInteger(publishArgs, "registration", registrationId);
	wamp_Publish(wamp, "wamp.registration.on_register", NULL, NULL, publishArgs);

	return 1;
}

STATIC int wamp_HandleRegistered(WAMP *wamp, JSON *json)
{
	return 1;
}

STATIC int wamp_HandleUnregister(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long registrationId = json_ArrayIntegerAt(json, 2);

	int ok = wamp_Unregister(wamp, registrationId);

	if (ok) {
		JSON *j = wamp_NewMessage(WAMP_UNREGISTERED, requestId);
		wamp_WriteJsonHeap(wamp, j);
	} else {
		wamp_SendErrorStr(wamp, WAMP_UNSUBSCRIBE, requestId, "You were not registered", ErrNoSuchRegistration, NULL, NULL);
	}

	return 1;
}

STATIC int wamp_HandleUnregistered(WAMP *wamp, JSON *json)
{
	return 1;
}

STATIC int wamp_DoWampRegistrationList(WAMP *wamp, long long callRequestId, SPMAP *options, JSON *argList, JSON *argDict)
{
	if (!wamp) return 0;
	WAMPREALM *realm = wamp->realm;

	JSON *registrationLists = json_NewObject();
	JSON *exactList = json_NewArray();
	JSON *prefixList = json_NewArray();
	JSON *wildcardList = json_NewArray();

	const char *name;
	wamp_callee_t *callee;
	int i;

	SPMAP *maps[3];
	maps[0] = realm->calleeMapExact;
	maps[1] = realm->calleeMapPrefix;
	maps[2] = realm->calleeMapWildcard;

	JSON *list[3];
	list[0] = exactList;
	list[1] = prefixList;
	list[2] = wildcardList;

	for (i=0; i<3; i++) {
		SPMAP *map = maps[i];

		if (map) {
			spmap_Reset(map);
			while (spmap_GetNextEntry(map, &name, (void**)&callee)) {
				json_ArrayAddInteger(list[i], callee->registrationId);
			}
		}
	}

	json_ObjectAdd(registrationLists, "exact", exactList);
	json_ObjectAdd(registrationLists, "prefix", prefixList);
	json_ObjectAdd(registrationLists, "wildcard", wildcardList);

	wamp_SendResult(wamp, callRequestId, NULL, NULL, registrationLists);

	return 1;
}

STATIC int wamp_DoWampRegistrationLookup(WAMP *wamp, long long callRequestId, SPMAP *options, JSON *argList, JSON *argDict)
{
	wamp_SendErrorStr(wamp, WAMP_CALL, callRequestId, "Cannot do wamp.registration.lookup yet", "wamp.error.no_such_procedure", NULL, NULL);
	return 1;
}

STATIC int wamp_HandleInternalCall(WAMP *wamp, long long callRequestId, SPMAP *options, const char *procedure, JSON *argList, JSON *argDict)
{
	if (!strcmp(procedure, "wamp.registration.list")) {
		return wamp_DoWampRegistrationList(wamp, callRequestId, options, argList, argDict);
	} else if (!strcmp(procedure, "wamp.registration.lookup")) {
		return wamp_DoWampRegistrationLookup(wamp, callRequestId, options, argList, argDict);
	} else if (!strcmp(procedure, "wamp.registration.match")) {
		wamp_SendErrorStr(wamp, WAMP_CALL, callRequestId, "Cannot do wamp.registration.match yet", "wamp.error.no_such_procedure", NULL, NULL);
	} else if (!strcmp(procedure, "wamp.registration.get")) {
		wamp_SendErrorStr(wamp, WAMP_CALL, callRequestId, "Cannot do wamp.registration.get yet", "wamp.error.no_such_procedure", NULL, NULL);
	} else if (!strcmp(procedure, "wamp.registration.list_callees")) {
		wamp_SendErrorStr(wamp, WAMP_CALL, callRequestId, "Cannot do wamp.registration.list_callees yet", "wamp.error.no_such_procedure", NULL, NULL);
	} else if (!strcmp(procedure, "wamp.registration.count_callees")) {
		wamp_SendErrorStr(wamp, WAMP_CALL, callRequestId, "Cannot do wamp.registration.count_callees yet", "wamp.error.no_such_procedure", NULL, NULL);
	} else {
		wamp_SendErrorStr(wamp, WAMP_CALL, callRequestId, procedure, "wamp.error.no_such_procedure", NULL, NULL);
		return 1;
	}
}

STATIC int wamp_HandleCall(WAMP *wamp, JSON *json)
{
	long long callRequestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *procedure = json_ArrayStringzAt(json, 3);
	JSON *argList = json_ArrayTakeAt(json, 4);
	JSON *argDict = json_ArrayTakeAt(json, 4);

	if (!strncmp(procedure, "wamp.", 5)) {
		return wamp_HandleInternalCall(wamp, callRequestId, options, procedure, argList, argDict);
	}

	long long registrationId = 0;
	wamp_invokee_t *invokee = wamp_FindInvokee(wamp, procedure, &registrationId);
	if (!invokee) {
		wamp_SendError(wamp, WAMP_CALL, callRequestId, NULL, "wamp.error.no_such_procedure", NULL, NULL);
		return 1;
	}

	// Here, we have someone available to handle the call
	long long invokeRequestId = wamp_RandomId();

	if (invokee->cb_invokee) {
		(invokee->cb_invokee)(wamp, callRequestId, procedure, argList, argDict);
		json_Delete(argList);
		json_Delete(argDict);
	} else {
		JSON *j = wamp_NewMessage(WAMP_INVOCATION, invokeRequestId);
		json_ArrayAddInteger(j, registrationId);
		JSON *callDetails = json_NewObject();
		json_ObjectAddStringz(callDetails, "procedure", procedure);
		json_ArrayAdd(j, callDetails);
		AddArguments(j, argList, argDict);

		WAMP *invokeeWamp = wamp_ByName(invokee->wampName);
		if (invokeeWamp) {
			wamp_AddCaller(wamp_Name(wamp), callRequestId, invokee->wampName, invokeRequestId, invokee);

			wamp_WriteJsonHeap(invokeeWamp, j);
		}
	}

	return 0;
}

STATIC int wamp_HandleInvocation(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long registrationId = json_ArrayIntegerAt(json, 2);
	JSON *details = json_ArrayAt(json, 3);
	JSON *argList = json_ArrayTakeAt(json, 4);
	JSON *argDict = json_ArrayTakeAt(json, 4);

Log("WA: INVOCATION: requestId = %Ld", requestId);
Log("WA: INVOCATION: registrationId = %Ld", registrationId);
Log("WA: INVOCATION: details = %s", json_Render(details));
Log("WA: INVOCATION: list = (%p) %s", argList, json_Render(argList));
Log("WA: INVOCATION: dict = (%p) %s", argDict, json_Render(argDict));
Log("WA: INVOCATION: wamp_Invokee = (%p)", wampcb_Invokee);

	const char *procedure = NULL;
	JSON *jProcedure = json_ObjectElementCalled(details, "procedure");
	if (jProcedure && json_Type(jProcedure) == JSON_STRING)
		procedure = json_AsStringz(jProcedure);

	if (wampcb_Invokee) {
		(*wampcb_Invokee)(wamp, requestId, procedure, argList, argDict);
	} else {
		wamp_NoInvokee(wamp, requestId, procedure, argList, argDict);
	}

	json_Delete(argList);
	json_Delete(argDict);

	return 0;
}

STATIC int wamp_HandleYield(WAMP *wamp, JSON *json)
{
	WAMP *callerWamp = NULL;

	long long requestId = json_ArrayIntegerAt(json, 1);
	long long callerRequestId;
	const char *callerName = wamp_FindAndRemoveCaller(requestId, &callerRequestId);
	//Log("WA: Name of caller = '%s'", callerName);
	if (callerName) {									// Should always find one
		callerWamp = wamp_ByName(callerName);			// May not find one if the wamp has 'gone away' since the call

		//Log("WA: Calling wamp = %p", callerWamp);
		szDelete(callerName);
	}

	if (callerWamp) {									// The caller still exists
		JSON *details = json_ArrayTakeAt(json, 2);
		JSON *resultList = json_ArrayTakeAt(json, 2);
		JSON *resultDict = json_ArrayTakeAt(json, 2);

		wamp_SendResult(callerWamp, callerRequestId, details, resultList, resultDict);
	}
	return 0;
}

STATIC int wamp_HandleSubscribe(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *topic = json_ArrayStringzAt(json, 3);
	WAMPREALM *realm = wamp->realm;

//Log("WA: Subscribing topic %s into realm %p", topic, realm);
	const char *match = "exact";
	JSON *jMatch = (JSON*)spmap_GetValue(options, "match");
	if (jMatch) {
		if (json_Type(jMatch) != JSON_STRING) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "OPTION value must be a string", ErrInvalidArgument, NULL, NULL);
			return 0;
		}
		match = json_AsStringz(jMatch);
	}

	SPMAP **pmap;
	if (!strcmp(match, "exact"))
		pmap = &realm->subMapExact;
	else if (!strcmp(match, "prefix"))
		pmap = &realm->subMapPrefix;
	else if (!strcmp(match, "wildcard"))
		pmap = &realm->subMapWildcard;
	else {
		wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "match must be exact, prefix or wildcard", ErrInvalidArgument, NULL, NULL);
		return 0;
	}
	if (!*pmap)						*pmap = spmap_New();						// Initialise the specific map if necessary
	if (!realm->allSubscriptions)	realm->allSubscriptions = idmap_New();		// Initialise the map of all subscriptions if nec.

	subscription_t *sub = spmap_GetValue(*pmap, topic);
	if (!sub) {
		sub = NEW(subscription_t, 1);
		sub->subscriptionId = wamp_RandomId();
		sub->wamps = spmap_New();
		spmap_Add(*pmap, topic, sub);
		idmap_Add(realm->allSubscriptions, sub->subscriptionId, sub);
	}

	subscription_info_t *subinfo = NEW(subscription_info_t, 1);
	subinfo->requestId = requestId;
	spmap_Add(sub->wamps, wamp_Name(wamp), subinfo);

	long long subscriptionId = sub->subscriptionId;

	JSON *j = wamp_NewMessage(WAMP_SUBSCRIBED, requestId);
	json_ArrayAddInteger(j, subscriptionId);

	wamp_WriteJsonHeap(wamp, j);
	return 0;
}

STATIC int wamp_HandleSubscribed(WAMP *wamp, JSON *json)
{
	Log("WA: Unhandled subscribed message: %s", json_Render(json));
	return 1;
}

STATIC int wamp_HandleUnsubscribe(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long subscriptionId = json_ArrayIntegerAt(json, 2);
	WAMPREALM *realm = wamp->realm;
	subscription_info_t *subinfo = NULL;

	if (realm->allSubscriptions) {
		subscription_t *sub = idmap_GetValue(realm->allSubscriptions, subscriptionId);
		const char *wampName = wamp_Name(wamp);

		subinfo = spmap_GetValue(sub->wamps, wampName);
		if (subinfo) {
// TODO: Might want to call a common deleting strategy here - see wamp_RemoveFromSubscribeeMap()
// Otherwise we will be leaving empty subscriptions
			spmap_DeleteKey(sub->wamps, wampName);
			long long originalRequestId = subinfo->requestId;		// Bugger - we really don't need this!
			free((char*)subinfo);
		} else {
		}
	}

	if (subinfo) {
		JSON *j = wamp_NewMessage(WAMP_UNSUBSCRIBED, requestId);
		wamp_WriteJsonHeap(wamp, j);
	} else {
		wamp_SendErrorStr(wamp, WAMP_UNSUBSCRIBE, requestId, "You were not subscribed", ErrNoSuchSubscription, NULL, NULL);
	}

	return 1;
}

STATIC int wamp_HandleUnsubscribed(WAMP *wamp, JSON *json)
{
	Log("WA: Unhandled unsubscribed message: %s", json_Render(json));
	return 1;
}

STATIC int wamp_HandlePublish(WAMP *wamp, JSON *json)
// We need to publish a topic
// Look through each of the three maps (exact, prefix, wildcard) for matching topics
// For each one that we find, add it to a list of subscriptions
// When we've done that, run through the list, sending a message to each WAMP.
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *topic = json_ArrayStringzAt(json, 3);
	JSON *argList = json_ArrayTakeAt(json, 4);
	JSON *argDict = json_ArrayTakeAt(json, 4);
	WAMPREALM *realm = wamp->realm;

	typedef struct sublist_t {							// This is our list of subscriptoins that we'll be publishing to
		struct sublist_t *prev;
		subscription_t *sub;
	} sublist_t;

	sublist_t *subs = NULL;

	if (realm->subMapExact) {											// Check for an exact match
		subscription_t *result = (subscription_t*)spmap_GetValue(realm->subMapExact, topic);
		if (result) {
			sublist_t *sub = NEW(sublist_t, 1);
			sub->sub = result;
			sub->prev = subs;
			subs = sub;
		}
	}

	if (realm->subMapPrefix) {											// Check for a prefix match
		const char *name;
		void *value;

		spmap_Reset(realm->subMapPrefix);
		while(spmap_GetNextEntry(realm->subMapPrefix, &name, &value)) {
			if (!strncmp(topic, name, strlen(name))) {
				subscription_t *result = (subscription_t*)value;

				sublist_t *sub = NEW(sublist_t, 1);
				sub->sub = result;
				sub->prev = subs;
				subs = sub;
			}
		}
	}

	if (realm->subMapWildcard) {										// Check for a wildcard match
		const char *name;
		void *value;

		spmap_Reset(realm->subMapWildcard);
		while(spmap_GetNextEntry(realm->subMapWildcard, &name, &value)) {
			if (wamp_WildcardMatch(name, topic)) {
				subscription_t *result = (subscription_t*)value;

				sublist_t *sub = NEW(sublist_t, 1);
				sub->sub = result;
				sub->prev = subs;
				subs = sub;
			}
		}
	}

	// We now have a linked list of subscribers that match this topic, so we'll set about sending events...
	if (subs) {
		long long publicationId = wamp_RandomId();

		JSON *event = wamp_NewMessage(WAMP_EVENT, 0);
		json_ArrayAddInteger(event, 0);								// This will be replaced by the relevant subscription ID
		json_ArrayAddInteger(event, publicationId);
		JSON *details = json_NewObject();
		json_ObjectAddStringz(details, "topic", topic);
		json_ArrayAdd(event, details);
		AddArguments(event, argList, argDict);

		while (subs) {
			sublist_t *sub = subs;

			long long subscriptionId = sub->sub->subscriptionId;
			spmap_Reset(sub->sub->wamps);
			const char *wampName;
			json_ArraySetAt(event, 1, json_NewInteger(subscriptionId));
			while (spmap_GetNextEntry(sub->sub->wamps, &wampName, NULL)) {
				WAMP *wRecip = wamp_ByName(wampName);

				if (wRecip) {
					wamp_WriteJson(wRecip, event);
				}
			}
			subs=sub->prev;
			free((char*)sub);
		}

		json_Delete(event);
	}

	return 1;
}

STATIC int wamp_HandlePublished(WAMP *wamp, JSON *json)
{
	Log("WA: Unhandled published message: %s", json_Render(json));
	return 1;
}

STATIC int wamp_HandleEvent(WAMP *wamp, JSON *json)
{
	Log("WA: Unhandled event message: %s", json_Render(json));
	return 1;
}

// This set of functions is used if we're forwarding subscription handling to another broker
STATIC int wamp_ForwardSubscribe(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);

	ssmap_Add(wamp->realm->fwdSubscriptionMap, buf, wamp_Name(wamp));       // Remember where this came from
	wamp_WriteJson(fwdWamp, json);

	return 0;
}

STATIC int wamp_ForwardSubscribed(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long subscriptionId = json_ArrayIntegerAt(json, 2);
	char buf[30];
	sprintf(buf, "%Ld", requestId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdSubscriptionMap, buf);
	if (sender) {
		char buf[30];
		sprintf(buf, "%Ld", subscriptionId);
		ssmap_Add(wamp->realm->fwdEventMap, buf, sender);                   // Remember who asked for this

		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the SUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("WA: SUBSRIBED(%s) not found", buf);
	}
	return 0;
}

STATIC int wamp_ForwardUnsubscribe(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);

	ssmap_Add(wamp->realm->fwdUnsubscriptionMap, buf, wamp_Name(wamp));       // Remember where this came from
	wamp_WriteJson(fwdWamp, json);

	return 0;
}

STATIC int wamp_ForwardUnsubscribed(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long subscriptionId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", subscriptionId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdUnsubscriptionMap, buf);
	if (sender) {
		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the UNSUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("WA: UNSUBSRIBED(%s) not found", buf);
	}
	return 0;
}

STATIC int wamp_ForwardPublish(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);

	ssmap_Add(wamp->realm->fwdPublishMap, buf, wamp_Name(wamp));            // Remember where this came from
	wamp_WriteJson(fwdWamp, json);

	return 0;
}

STATIC int wamp_ForwardPublished(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdPublishMap, buf);

	if (sender) {
		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the SUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("WA: SUBSRIBED(%s) not found", buf);
	}
	return 0;
}

STATIC int wamp_ForwardEvent(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long subscriptionId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", subscriptionId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdEventMap, buf);
//Log("WA: Event found (%p, %s) = %s", wamp->realm->fwdEventMap, buf, sender?sender:"NULL");

	if (sender) {
		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the SUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("WA: In event: SUBSRIBED(%s) not found", buf);
	}
	return 0;
}

API int wamp_SetForwardSubscriptions(const char *realmName, int enable, WAMP *wamp)
{
	if (realmName) {
		WAMPREALM *realm = wamp_RealmByName(realmName);

		if (realm) {
			realm->forwardSubscriptions = wamp ? wamp_Name(wamp) : NULL;
			realm->wantForwardSubscriptions = enable;
			return 0;
		}
	}

	return 1;
}

API int wamp_Publish(WAMP *wamp, const char *topic, SPMAP *options, JSON *argList, JSON *argDict)
// Publishes the topic
// Takes ownership of options, argList and argDict.
{
Log("wamp_Publish(%s, %s, %p, %p, %p)", wamp_Name(wamp), topic, options, argList, argDict);
	JSON *json = wamp_NewMessage(WAMP_PUBLISH, wamp_RandomId());

	JSON *callDetails = json_NewObjectWith(options);
	json_ArrayAdd(json, callDetails);
	json_ArrayAddStringz(json, topic);
	AddArguments(json, argList, argDict);

	wamp_Dispatch(wamp, WAMP_PUBLISH, json);
	json_Delete(json);
}

API int wamp_Dispatch(WAMP *wamp, int type, JSON *json)
// Does whatever needs to be done to deal with a message of type 'type'
// The JSON* provided is definitely an array with at least one element.
// Returns 0 or an error code
{
LogString(wamp, "WAMP IN", json_Render(json));

	int err = wamp_Validate(wamp, type, json);
	if (err) return err;


	if (type == WAMP_ABORT) {							// We sent a HELLO, the far end didn't like it
		return 1;
	}

	if (type != WAMP_HELLO && type != WAMP_WELCOME && !wamp->session) {			// Trying to say something other than hello and we've not shaken hands yet
		wamp_Abort(wamp, ErrInvalidArgument, "You have not been welcomed");
		return 1;
	}

	WAMP *fwdWamp = NULL;							// Assume we're not forwarding this message

	WAMPCB_Handler fn = (WAMPCB_Handler)idmap_GetValue(wamp->handlers, (long long)type);
//Log("WA: Specific handler = %p", fn);
	if (fn) {
		int result = (*fn)(wamp, type, json);
		if (result != -1) return result;
	}

	if (wamp->realm) {
		WAMPCB_Handler fn = (WAMPCB_Handler)idmap_GetValue(wamp->realm->redirect, (long long)type);

		if (fn) {
			int result = (*fn)(wamp, type, json);
			if (result != -1) return result;
		}

//Log("WA: Have realm '%s', wantForward = %d, to %s", wamp->realm->name, wamp->realm->wantForwardSubscriptions, wamp->realm->forwardSubscriptions ? wamp->realm->forwardSubscriptions : NULL);
		if (wamp_IsSubscriptionType(type)) {
			if (wamp->realm->wantForwardSubscriptions) {
				fwdWamp = wamp_ByName(wamp->realm->forwardSubscriptions);		// Will be NULL if it's not valid
				if (!fwdWamp) {													// Asked to forward but our wamp's gone...
					wamp_SendError(wamp, 0, 0, NULL, "wamp.cannot_handle_subscriptions", NULL, NULL);
					return 2;
				}
			}
		}

		if (wamp_IsCallType(type)) {
		}
	} else {
//Log("WA: WAMP \"%s\"(%p) with no realm...", wamp_Name(wamp), wamp);
	}

//Log("WA: Dispatching type %s", wamp_TypeName(type));
	switch (type) {
	case WAMP_HELLO:		return wamp_HandleHello(wamp, json);
	case WAMP_WELCOME:		return wamp_HandleWelcome(wamp, json);
	case WAMP_GOODBYE:		return wamp_HandleGoodbye(wamp, json);
	case WAMP_ERROR:		return wamp_HandleError(wamp, json);
	case WAMP_REGISTER:		return wamp_HandleRegister(wamp, json);
	case WAMP_REGISTERED:	return wamp_HandleRegistered(wamp, json);
	case WAMP_UNREGISTER:	return wamp_HandleUnregister(wamp, json);
	case WAMP_UNREGISTERED:	return wamp_HandleUnregistered(wamp, json);
	case WAMP_CALL:			return wamp_HandleCall(wamp, json);
	case WAMP_INVOCATION:	return wamp_HandleInvocation(wamp, json);
	case WAMP_YIELD:		return wamp_HandleYield(wamp, json);
	case WAMP_SUBSCRIBE:	return fwdWamp ? wamp_ForwardSubscribe(wamp, fwdWamp, json)
											  : wamp_HandleSubscribe(wamp, json);
	case WAMP_SUBSCRIBED:	return fwdWamp ? wamp_ForwardSubscribed(wamp, fwdWamp, json)
											  : wamp_HandleSubscribed(wamp, json);
	case WAMP_UNSUBSCRIBE:	return fwdWamp ? wamp_ForwardUnsubscribe(wamp, fwdWamp, json)
											  : wamp_HandleUnsubscribe(wamp, json);
	case WAMP_UNSUBSCRIBED:	return fwdWamp ? wamp_ForwardUnsubscribed(wamp, fwdWamp, json)
											  : wamp_HandleUnsubscribed(wamp, json);
	case WAMP_PUBLISH:		return fwdWamp ? wamp_ForwardPublish(wamp, fwdWamp, json)
											  : wamp_HandlePublish(wamp, json);
	case WAMP_PUBLISHED:	return fwdWamp ? wamp_ForwardPublished(wamp, fwdWamp, json)
											  : wamp_HandlePublished(wamp, json);
	case WAMP_EVENT:		return fwdWamp ? wamp_ForwardEvent(wamp, fwdWamp, json)
											  : wamp_HandleEvent(wamp, json);
	default:
		{
			const char *msg = hprintf(NULL, "I can't handle a '%s' message (yet)", wamp_TypeName(type));
			wamp_SendErrorStr(wamp, type, 0, msg, ErrInvalidArgument, NULL, NULL);
			szDelete(msg);
		}
	}

	return 0;
}
