#if 0
// Channels
// A channel describes a connection through which websocket messages can travel.
// A channelList is used for an event loop that monitors those channels and coordinates data flow
// A channel can only be in one channelList at a time

#define WS_IN		1				// This event receives stuff from io/fd
#define WS_OUT		2				// This event feeds it's output queue to io/fd
#define WS_DIRTY	4				// Indication that incoming data has been received in poll() loop
#define WS_CLOSE	8				// We are requesting that this channel closes

typedef struct WSL {
	SPMAP *map;						// Map of channels
} WSL;

typedef struct WS {
	WSL *list;			// The list this channel is in, if any
	char *id;						// A unique ID for this channel (currntly the 'fd' as a string)
	int fd;							// File descriptor (valid even if io is non-NULL)
	BIO *io;						// io structure (NULL if we're using a plain fd)
	HLIST *in;						// incoming queue (never NULL)
	HLIST *out;						// Outgoing queue (never NULL)
	unsigned char opcode;			// Current opcode (used to handle continution frames)
	HBUF *inbuf;					// Used if we have fragments
	int flags;						// Bit mask of WS_*
} WS;

typedef struct wamp_realm_t {
	const char *name;
} wamp_realm_t;

typedef struct wamp_session_t {
	long long id;
	wamp_realm_t *realm;
} wamp_session_t;

typedef struct WAMP {
	WS *channel;					// The websocket channel this WAMP lives on
	wamp_realm_t *realm;
	wamp_session_t *session;
} WAMP;

#define WAMP_HELLO			1
#define WAMP_WELCOME		2
#define WAMP_ABORT			3
#define WAMP_GOODBYE		6

#define WAMP_ERROR			8

#define WAMP_PUBLISH		16
#define WAMP_PUBLISHED		17

#define WAMP_SUBSCRIBE		32
#define WAMP_SUBSCRIBED		33
#define WAMP_UNSUBSCRIBE	34
#define WAMP_UNSUBSCRIBED	35
#define WAMP_EVENT			36

#define WAMP_CALL			48
#define WAMP_RESULT			50

#define WAMP_REGISTER		64
#define WAMP_REGISTERED		65
#define WAMP_UNREGISTER		66
#define WAMP_UNREGISTERED	67
#define WAMP_INVOCATION		68
#define WAMP_YIELD			70

struct wamp_code_t {
	int code;
	const char *name;
} wamp_codes[] = {
	{WAMP_HELLO,			"Hello"},
	{WAMP_WELCOME,			"Welcome"},
	{WAMP_ABORT,			"Abort"},
	{WAMP_GOODBYE,			"Goodbye"},

	{WAMP_ERROR,			"Error"},

	{WAMP_PUBLISH,			"Publish"},
	{WAMP_PUBLISHED,		"Published"},

	{WAMP_SUBSCRIBE,		"Subscribe"},
	{WAMP_SUBSCRIBED,		"Subscribed"},
	{WAMP_UNSUBSCRIBE,		"Unsubscribe"},
	{WAMP_UNSUBSCRIBED,		"Unsubscribed"},
	{WAMP_EVENT,			"Event"},

	{WAMP_CALL,				"Call"},
	{WAMP_RESULT,			"Result"},

	{WAMP_REGISTER,			"Register"},
	{WAMP_REGISTERED,		"Registered"},
	{WAMP_UNREGISTER,		"Unregister"},
	{WAMP_UNREGISTERED,		"Unregistered"},
	{WAMP_INVOCATION,		"Invocation"},
	{WAMP_YIELD,			"Yield"},

	{0,NULL}
};

const char *json_Error(JSON *j)
// Returns	NULL	There isn't an error
//			char*	Pointer to a static error message
{
	if (j) {
		return j->type == JSON_ERROR ? j->data.string.string : NULL;
	} else {
		return "NULL JSON";
	}
}

long long wamp_RandomId()
// Returns a random number 1..2^53-1
{
	static int seeded = 0;

	if (!seeded) {
		seeded = 1;
		srand48(time(NULL));
	}

	long long result = 0;
	while (result == 0) {					// Dangerous but if it doesn't exit, the random number generator has gone weird
		long long a = lrand48();			// Unsigned
		long long b = lrand48();			// Unsigned
		result = a ^ (b<<5);
	}

	return result;
}

SPMAP *allWampChannels = NULL;

WAMP *wamp_New()
{
	WAMP *w = NEW(WAMP, 1);

	w->channel = NULL;
	w->session = NULL;
	w->realm = NULL;

	return w;
}

WAMP *wamp_GetForChannel(WS *channel)
{
	WAMP *w = NULL;

	if (channel) {
		if (!allWampChannels) allWampChannels = spmap_New();

		const char *id = channel->id;
		w = (WAMP*)spmap_GetValue(allWampChannels, id);
		if (!w) {
			w = wamp_New();

			spmap_Add(allWampChannels, id, (void*)w);
			w->channel = channel;
		}
	}

	return w;
}

int ws_WriteHeap(WS *channel, int len, const char *data)
// Just like ws_Write() but deletes the data afterwards
{
	int result = 0;

	if (channel && len && data) {
//LogBuffer("Pushing onto heap:", len, data);
		hlist_PushHeap(channel->out, len, data);
		result = len;
	}

	return result;
}

int ws_Write(WS *channel, int len, const char *data)
// Put some data on the WebSocket (by adding it to its output queue)
{
	int result = 0;

	if (channel && len && data) {
		if (len == -1) len = strlen(data);

		char *heapCopy = malloc(len);
		memcpy(heapCopy, data, len);
		result = ws_Write(channel, len, heapCopy);
	}

	return result;
}

int wamp_Write(WAMP *wamp, const char *message)
// Write a string to this WAMP's output channel
// Returns the number of bytes sent
{
	int result = 0;

	if (wamp && message) {
		int fragLen;
		const char *frag = ws_MakeFragment(1, 1, 0, -1, message, &fragLen);

		result = ws_WriteHeap(wamp->channel, fragLen, frag);
	}

	return result;
}

int wamp_WriteHeap(WAMP *wamp, const char *message)
// Exactly like wamp_Write() but deletes the message afterwards
{
	int result = wamp_Write(wamp, message);
	szDelete(message);

	return result;
}

void wamp_WriteJson(WAMP *wamp, JSON *json)
{
	const char *message = json_Render(json);
	if (message) {
Log("wamp_WriteJson(%p, %s)", wamp, message);
		wamp_WriteHeap(wamp, message);
	} else {
		Log("Duff JSON passed to wamp_SendJson");
	}
}

void wamp_WriteJsonHeap(WAMP *wamp, JSON *json)
{
	wamp_WriteJson(wamp, json);
	json_Delete(json);
}

void ws_CloseToBuffer(HLIST *h, int code, const char *fmt, ...);

void wamp_CloseAbort(WAMP *wamp, int type, const char *uri, const char *reason)
// Close and Abort formats are identical apart from the type
{
	JSON *j = json_NewArray();
	json_ArrayAddInteger(j, type);
	JSON *jreason = json_ArrayAdd(j, json_NewObject());
	if (reason)
		json_ObjectAddString(jreason, "reason", -1, reason);
	json_ArrayAddString(j, -1, uri);

	wamp_WriteJson(wamp, j);
	json_Delete(j);
}

void wamp_Abort(WAMP *wamp, const char *uri, const char *reason)
{
	wamp_CloseAbort(wamp, WAMP_ABORT, uri, reason);
}

void wamp_Close(WAMP *wamp, const char *uri, const char *reason)
// Sends a WAMP close message with the given reason
{
	wamp_CloseAbort(wamp, WAMP_GOODBYE, uri, reason);
}

SPMAP *realm_Map()
{
	static SPMAP *realm_map = NULL;

	if (!realm_map) {
		realm_map = spmap_New();

		wamp_realm_t *r = NEW(wamp_realm_t, 1);
		r->name = strdup("spider");
		spmap_Add(realm_map, "spider", r);
	}

	return realm_map;
}

wamp_realm_t *wamp_GetRealm(const char *name)
{
	return (wamp_realm_t*)spmap_GetValue(realm_Map(), name);
}

wamp_session_t *wamp_NewSession(wamp_realm_t *realm)
{
	static long long id = 0;

	wamp_session_t *s = NEW(wamp_session_t, 1);

	s->id = wamp_RandomId();
//	s->id = ++id;							// TODO: This should probably be co-ordinated with the daemon
	s->realm = realm;

	return s;
}

long long session_Id(wamp_session_t *session)
{
	return session ? session->id : 0;
}

wamp_session_t *wamp_GetSession(long long id)
{
	return NULL;
}

// Connection provided an incorrect URI for any URI-based attribute of WAMP message,
// such as realm, topic or procedure.
const char *ErrInvalidUri = "wamp.error.invalid_uri";

// A Dealer could not perform a call, since no procedure is currently
// registered under the given URI.
const char *ErrNoSuchDomain = "wamp.error.no_such_procedure";

// A procedure could not be registered, since a procedure with the given URI
// is already registered.
const char *ErrDomainAlreadyExists = "wamp.error.procedure_already_exists";

// A Dealer could not perform an unregister, since the given registration is
// not active.
const char *ErrNoSuchRegistration = "wamp.error.no_such_registration";

// A Broker could not perform an unsubscribe, since the given subscription is
// not active.
const char *ErrNoSuchSubscription = "wamp.error.no_such_subscription";

// A call failed, since the given argument types or values are not acceptable
// to the called procedure - in which case the Callee may throw this error. Or
// a Node performing payload validation checked the payload (args / kwargs)
// of a call, call result, call error or publish, and the payload did not
// conform - in which case the Node may throw this error.
const char *ErrInvalidArgument = "wamp.error.invalid_argument";

// The Connection is shutting down completely - used as a GOODBYE (or aBORT) reason.
const char *ErrSystemShutdown = "wamp.error.system_shutdown";

// The Connection wants to leave the realm - used as a GOODBYE reason.
const char *ErrCloseRealm = "wamp.error.close_realm";

// A Connection acknowledges ending of a session - used as a GOOBYE reply reason.
const char *ErrGoodbyeAndOut = "wamp.error.goodbye_and_out";

// A join, call, register, publish or subscribe failed, since the Connection is not
// authorized to perform the operation.
const char *ErrNotAuthorized = "wamp.error.not_authorized";

// A Dealer or Broker could not determine if the Connection is authorized to perform
// a join, call, register, publish or subscribe, since the authorization
// operation itself failed. E.g. a custom authorizer ran into an error.
const char *ErrAuthorizationFailed = "wamp.error.authorization_failed";

// Connection wanted to join a non-existing realm (and the Node did not allow to
// auto-create the realm)
const char *ErrNoSuchRealm = "wamp.error.no_such_realm";

// A Connection was to be authenticated under a Role that does not (or no longer)
// exists on the Node. For example, the Connection was successfully authenticated,
// but the Role configured does not exists - hence there is some
// misconfiguration in the Node.
const char *ErrNoSuchRole = "wamp.error.no_such_role";

int wamp_Validate(WAMP *wamp, int type, JSON *json)
// Checks the validity of the message, sending an error back if there is a problem
// Returns	0		Ok
//			1...	Problem
{
	int result = 0;

	typedef struct {
		int type;
		int min;
		int max;
		const char *signature;				// I=int, F=Float, N=number, B=bool, O=object, U=Uri, A=Array, S=String
	} valid_t;

	static valid_t valids[] = {
		{WAMP_HELLO,3,3,"ISO"},
		{WAMP_CALL,4,6,"IIOUAO"},
		{0,0,0,0}
	};

	valid_t *v = valids;
	while (v->type) {
		if (v->type == type) {
			int argc = json_GetArrayCount(json);

			if (argc < v->min || argc > v->max) {
				const char *msg;

				if (v->min == v->max) {
					msg = hprintf(NULL, "Message type %d must have %d elements", type, v->min);
				} else {
					msg = hprintf(NULL, "Message type %d must have %d-%d elements", type, v->min, v->max);
				}
				wamp_Abort(wamp, "wamp.error.invalid_argument", msg);
				szDelete(msg);
				result = 1;
				break;
			}

			int i=0;
			const char *expected = NULL;
			for (i=0;i<argc;i++) {
				char check = v->signature[i];
				char actual = json_Type(json_GetArrayAt(json, i));

				if (check == 'I' && actual != JSON_INTEGER) {
					expected = "INTEGER";
				} else if (check == 'N' && actual != JSON_FLOAT && actual != JSON_INTEGER) {
					expected = "NUMBER";
				} else if (check == 'B' && actual != JSON_BOOL) {
					expected = "true or false";
				} else if (check == 'O' && actual != JSON_OBJECT) {
					expected = "object";
				} else if (check == 'A' && actual != JSON_ARRAY) {
					expected = "array";
				} else if (check == 'U' && actual != JSON_STRING) {
					expected = "URI";
				} else if (check == 'S' && actual != JSON_STRING) {
					expected = "string";
				}

				if (expected) {
					const char *found = "something else";
					if (actual == JSON_INTEGER)	found = "integer";
					else if (actual == JSON_FLOAT) found = "float";
					else if (actual == JSON_BOOL) found = "boolean";
					else if (actual == JSON_NULL) found = "null";
					else if (actual == JSON_OBJECT) found = "object";
					else if (actual == JSON_ARRAY) found = "array";
					else if (actual == JSON_STRING) found = "string";

					const char *msg = hprintf(NULL, "Message type %d, element %d should be %s not %s", type, i+1, expected, found);
					wamp_Abort(wamp, "wamp.error.invalid_argument", msg);
					szDelete(msg);
					result = 2;
					break;
				}
			}

			break;
		}
		v++;
	}

	return result;
}

int wamp_Dispatch(WAMP *wamp, int type, JSON *json)
// Does whatever needs to be done to deal with a message of type 'type'
// The JSON* provided is definitely an array with at least one element.
// Returns 0 or an error code
{
{const char *text = json_Render(json); Log("WAMP IN(%d): %s", type, text); szDelete(text);}

	int err = wamp_Validate(wamp, type, json);
	if (err) return err;

	int argc = json_GetArrayCount(json);
	// We now know that we have a good number of arguments and that their types match what we expect

	switch (type) {
	case WAMP_HELLO:
	{
		if (wamp->session) {
			wamp_Abort(wamp, "wamp.error.invalid_argument", "WAMP HELLO received within a session");
			return 1;
		}

		JSON *jRealm = json_GetArrayAt(json, 1);
		const char *szRealm = json_GetString(jRealm);
		wamp->realm = wamp_GetRealm(szRealm);
		if (!wamp->realm) {
			wamp_Abort(wamp, "wamp.error.no_such_realm", "I can only accept \"spider\" currently");
			return 1;
		}

		wamp->session = wamp_NewSession(wamp->realm);
		long long id = session_Id(wamp->session);

		JSON *json = json_NewArray();
		json_ArrayAddInteger(json, WAMP_WELCOME);
		json_ArrayAddInteger(json, id);
		JSON *opts = json_NewObject();
		json_ObjectAddString(opts, "agent", -1, "SPIDER " VERSION);
		json_ObjectAddString(opts, "roles", -1, "broker");
		json_ArrayAdd(json, opts);

		wamp_WriteJsonHeap(wamp, json);
		return 0;
	}
	case WAMP_GOODBYE:
		wamp_Close(wamp, "wamp.error.goodbye_and_out", NULL);
		return 0;
	case WAMP_CALL:
	{
		JSON *jid = json_GetArrayAt(json, 1);
		if (json_Type(jid) != JSON_INTEGER) {
			Log("WAMP CALL id must be an integer");
			return 1;
		}
		long long id = json_GetInteger(jid);

		JSON *jProcedure = json_GetArrayAt(json, 3);
		const char *procedure = json_GetString(jProcedure);

		JSON *json = json_NewArray();
		json_ArrayAddInteger(json, WAMP_RESULT);
		json_ArrayAddInteger(json, id);

		JSON *opts = json_NewObject();
		json_ArrayAdd(json, opts);

		JSON *res = json_NewArray();
		JSON *xx = json_NewArray();
		json_ArrayAddString(xx, -1, "Hello wamper!");
		json_ArrayAddString(xx, -1, procedure);
		json_ArrayAdd(res, xx);
		json_ArrayAdd(json, res);

		wamp_WriteJsonHeap(wamp, json);
	}
		return 0;
	default:
		wamp_Close(wamp, "wamp.error.invalid_argument", "I'm sorry but I can't handle that type of message");
	}

	Log("Dispatching WAMP(%d)", type);
	return 0;
}

int ws_HandleIncomingUtf8(WS *channel, int len, const char *text)
// This function handles UTF8 data coming in on the WebSocket channel.
// Currently this can only be destined for the WAMP system and this is effectively the interface function.
// Returns	0		All went well and was handled
//			1...	Fatal error - close connection
{
//Log("WS-UTF8(%d): %.*s", len, len, text);

	JSON *j = json_Parse(NULL, &text);

	HLIST *out = channel->out;
	const char *err = json_Error(j);
	if (err) {
		hlist_AddHeap(out, -1, hprintf(NULL, "JSON parse failure: %s", err));
		return 1;
	}
	if (json_Type(j) != JSON_ARRAY) {
		hlist_Add(out, -1, "Message must be a JSON array");
		return 1;
	}
	if (json_GetArrayCount(j) < 1) {
		hlist_Add(out, -1, "JSON message must have at least one element");
		return 1;
	}
	JSON *element1 = json_GetArrayAt(j, 0);
	if (json_Type(element1) != JSON_INTEGER) {
		hlist_Add(out, -1, "WAMP message type must be an integer");
		return 1;
	}
	int messageType = json_GetInteger(element1);

	WAMP *wamp = wamp_GetForChannel(channel);

	return wamp_Dispatch(wamp, messageType, j);
}

WSL * ws_NewChannelList()
{
	WSL *cl = NEW(WSL, 1);

	cl->map = spmap_New();

	return cl;
}

int ws_RemoveChannel(WS *c)
// Removes the channel from its list but DOES NOT delete it
// Returns 1 if it was removed, 0 if it wasn't in a list
{
	int result = 0;

	if (c && c->list) {
		WS *channel = spmap_GetValue(c->list->map, c->id);
		if (channel) {
			spmap_DeleteKey(c->list->map, c->id);
			result = 1;
		}
		c->list = NULL;
	}

	return result;
}

void ws_AddChannel(WSL *cl, WS *c)
// Adds a channel to a list or, if cl == NULL, removes it from its list
{
	if (!c) return;

	if (cl != c->list) {										// Something to do
		if (c->list) ws_RemoveChannel(c);						// Remove it from any existing list

		if (cl) {												// It's in a list already
			spmap_Add(cl->map, c->id, (void*)c);
			c->list = cl;
		} else {
			ws_RemoveChannel(c);
		}
	}
}

WS *ws_NewChannel(WSL *cl, int fd, BIO *io, int flags)
// Creates a new channel and adds it to the list (if non NULL)
// fd = 0..., io = NULL		// Plain 'fd' connection
// fd = -1, io = BIO*		// BIO * connection (fd is ascertained from io)
// flags					// a combination of WS_* values
{
	WS *channel = NEW(WS, 1);

	if (fd == -1 && io != NULL)						// Get fd if not provided
		BIO_get_fd(io, &fd);

	channel->id = hprintf(NULL, "%d", fd);
	channel->list = NULL;
	channel->fd = fd;
	channel->io = io;
	channel->flags = flags;
	channel->in = hlist_New();
	channel->out = hlist_New();
	channel->inbuf = hbuf_New();
	channel->opcode = 0;

	if (cl) ws_AddChannel(cl, channel);

	return channel;
}

void ws_DeleteChannel(WS *c)
// Deleting a channel will automatically remove it from its list (if it's in one)
{
	if (c) {
		ws_RemoveChannel(c);

		szDelete(c->id);
		hlist_Delete(c->in);
		hlist_Delete(c->out);
		hbuf_Delete(c->inbuf);
		free((char*)c);
	}
}

WS *ws_FindChannelByFd(WSL *cl, int fd)
// Given an fd, finds a channel in a list or NULL if it's not there
{
	if (!cl) return NULL;

	char key[20];

	sprintf(key, "%d", fd);
	return spmap_GetValue(cl->map, key);
}

void ws_PushMessage(HLIST *h, int immediate, int opcode, int len, const char *data)
{
//Log("ws_Pushmessage(%x, %d, %d, %d, %p)",h,immediate,opcode,len,data);
	int fraglen;
	const char *fragment = ws_MakeFragment(1, opcode, 0, len, data, &fraglen);

	if (immediate)
		hlist_Push(h, fraglen, fragment);
	else
		hlist_Add(h, fraglen, fragment);

	free((char*)fragment);
}

void ws_CloseToBuffer(HLIST *h, int code, const char *fmt, ...)
{
//Log("ws_CloseToBuffer(%p, %d, %s, ...)", h, code, fmt);
	char buf[256];
	char *p = buf;

	if (code != 0 || fmt != NULL) {
		p[0]=code >> 8;
		p[1]=code;
		p+=2;
	}

	if (fmt) {
		va_list ap;

		va_start(ap, fmt);
		vsnprintf(p, sizeof(buf)-(p-buf), fmt, ap);
		va_end(ap);
		p+=strlen(p);
	}

	ws_PushMessage(h, 1, 8, p-buf, buf);
}

int ws_HandleIncoming(WS *channel)
// Returns 1 if we successfully removed something from the queue
// TODO: Need a way of handling an error here...
{
	int got;
	HLIST *h = channel->in;
	const unsigned char *header = (const unsigned char*)hlist_Peek(h, 10, &got);

	if (got < 2) return 0;			// Not enough to do anything with
	unsigned char fin = header[0] & 0x80;
	unsigned char op = header[0] & 0x0f;
	unsigned char masked = header[1] & 0x80;
	unsigned char len = header[1] & 0x7f;
	int needed = (len < 126) ? 2 : len == 126 ? 4 : 6;
	if (masked) needed += 4;
	if (got < needed) return 0;		// Not enough for length and mask

	long length;					// Length of block
	unsigned long mask = 0;			// Mask if it is masked
	if (len < 126) {
		length = len;
	} else if (len == 126) {
		length = header[2] << 8 | header[3];
	} else {
		length = header[2] << 24 | header[3] << 16 | header[4] << 8 | header[5];
	}
	if (masked) {
		mask = header[needed-4] << 24 | header[needed-3] << 16 | header[needed-2] << 8 | header[needed-1];
	}

	if (hlist_Length(h) < needed+length)
		return 0;					// After all that, there wasn't that much data there

	const char *data = malloc(needed+length+1);		// +1 as we'll plonk a nice '\0' on the end
	hlist_GetDataToBuffer(h, needed+length, (void*)data);

	header = (const unsigned char *)data;
	data = (char*)(header+needed);	// header is now only so we can properly free later, data is the actual data (len = length)
	((char*)data)[length]='\0';				// Terminate it to make parsing etc. so much easier

	if (mask) {						// Need exclusive OR our way over the data with the mask
		ws_ApplyMask(mask, length, data);
	}

	int dataAllocated = 0;			// 1 if data is a separate heap buffer that'll want freeing

	if (!fin) {						// This is only part of a message
		if (op) {
		   if (hbuf_GetLength(channel->inbuf)) {// Error - opcode should be 0 for fragments 2...
			   ws_CloseToBuffer(channel->out, 1002, "Non-zero opcode in continuation frame");
			   return 1;
		   } else {
				channel->opcode = op;
		   }
		}
		hbuf_AddBuffer(channel->inbuf, length, data);
		free((char*)header);
		return 1;
	} else {
		if (hbuf_GetLength(channel->inbuf)) {		// We have some prefixing data
			if (op) {
				ws_CloseToBuffer(channel->out, 1002, "Non-zero opcode in final frame of multi-frame message");
				return 1;
			}
			op = channel->opcode;
			hbuf_AddBuffer(channel->inbuf, length, data);
			length = hbuf_GetLength(channel->inbuf);
			data = hbuf_ReleaseBuffer(channel->inbuf);
			dataAllocated = 1;
			header = (const unsigned char *)realloc((void*)header, needed);
		}
	}
	// NB. At this point we may have two layouts for header and data
	// A single block allocated as header+data	- Message was a single fragment (dataAllocated = 0)
	// Separate header and data blocks			- Message was in fragments (dataAllocated = 1)

	switch (op) {
		case 0:									// Error, opcode should not be 0 at this stage
			ws_CloseToBuffer(channel->out, 1002, "Zero opcode in message");
			break;
		case 1:									// UTF-8 text
			ws_HandleIncomingUtf8(channel, length, data);		// Assuming WAMP at this point
			break;
		case 2:									// Binary data
			break;
		case 8:									// Close
			ws_CloseToBuffer(channel->out, 1000, "Goodbye");
			break;
		case 9:									// Ping
LogBuffer("PingPong", length, data);
			ws_PushMessage(channel->out, 0, 10, length, data);	// Send a pong
			break;
		case 10:								// Pong
			break;
		default:
			break;
	}

	free((char*)header);
	if (dataAllocated) free((char*)data);

	return 1;
}
#endif
