#if 0
./makeh $0
exit 0
#endif

extern void Log(const char *, ...);

#include "mtwamp.h"

#include <string.h>

#include <mtmacro.h>
#include <heapstrings.h>

#define STATIC static
#define API

#if 0
// START HEADER

#include "smap.h"

#include "mtwebsocket.h"
#include "mtjson.h"

#define IDMAP	SPMAP

// Typedefs for WAMP callback functions
struct WAMP;
typedef int (*WAMPCB_NoCallee)(const char *name);
typedef void (*WAMPCB_Invokee)(struct WAMP *wamp, long long requestId, const char *procedure, JSON *list, JSON *dict);
typedef void (*WAMPCB_Data)(struct WAMP *wamp, JSON *json);
typedef int (*WAMPCB_Handler)(struct WAMP *wamp, int type, JSON *json);

typedef struct WAMP {
	const char *name;				// Unique ID for this wamp
	int connectionType;				// 1 = websocket, 2 = rawsocket, 3 = code (not currently implemented)
	union {
		WS *ws;						// The websocket this WAMP lives on
		WAMPCB_Data fn;				// Call back routine for code-based WAMPS
	} connection;
	IDMAP *handlers;
	struct WAMPREALM *realm;
	struct WAMPSESSION *session;
} WAMP;

#define WAMP_EXACT			1		// Used in wamp_RegisterCallee
#define WAMP_PREFIX			2
#define WAMP_WILDCARD		3

#define WAMP_HELLO			1
#define WAMP_WELCOME		2
#define WAMP_ABORT			3
#define WAMP_GOODBYE		6

#define WAMP_ERROR			8

#define WAMP_PUBLISH		16
#define WAMP_PUBLISHED		17

#define WAMP_SUBSCRIBE		32
#define WAMP_SUBSCRIBED		33
#define WAMP_UNSUBSCRIBE	34
#define WAMP_UNSUBSCRIBED	35
#define WAMP_EVENT			36

#define WAMP_CALL			48
#define WAMP_RESULT			50

#define WAMP_REGISTER		64
#define WAMP_REGISTERED		65
#define WAMP_UNREGISTER		66
#define WAMP_UNREGISTERED	67
#define WAMP_INVOCATION		68
#define WAMP_YIELD			70

// END HEADER
#endif

#define WAMP_INVOKE_SINGLE		1
#define WAMP_INVOKE_ROUNDROBIN	2
#define WAMP_INVOKE_RANDOM		3
#define WAMP_INVOKE_FIRST		4
#define WAMP_INVOKE_LAST		5

typedef struct WAMPREALM {
	const char *name;
	SPMAP *calleeMapExact;						// Map of known callees with exact call
	SPMAP *calleeMapPrefix;						// Map of known callees	with prefix call
	SPMAP *calleeMapWildcard;					// Map of known callees with wildcard call
	IDMAP *redirect;							// Re-direction map (see. wamp_RegisterRedirect())

	SPMAP *subMapExact;							// Three maps to handle subsscriptions
	SPMAP *subMapPrefix;
	SPMAP *subMapWildcard;
	IDMAP *allSubscriptions;					// All subscriptions by subscription ID

// wantForwardSubscriptions = 0									We are handling subscriptions
// wantForwardSubscriptions = 1, forwardSubscriptions != NULL	We can't handle them, but we can forward them
// wantForwardSubscriptions = 1, forwardSubscriptions = NULL	We can't handle them at all
	int wantForwardSubscriptions;				// 1 if we want to forward subscriptions
	const char *forwardSubscriptions;			// WAMP to which to forward subscriptions or NULL not to forward
	SSMAP *fwdSubscriptionMap;					// Records who is subscribing to messages
	SSMAP *fwdUnsubscriptionMap;				// Records who is unsubscribing to messages
	SSMAP *fwdEventMap;							// Records who wants to know about events
	SSMAP *fwdPublishMap;						// Records who has published
} WAMPREALM;

typedef struct WAMPSESSION {
	long long id;
	WAMPREALM *realm;
} WAMPSESSION;

/* WAMP ROUTING


# Do we want / need to be able to advertise a callee and address it from anywhere?
# E.g. snomed.register might be provided on a specific server, but we don't want the caller to need to know that.

# Would we, therefore, want a list of 'advertised' callees on each node, which gets distributed when a node sends
# a discovery message?  Also, presumably, if a node sees one of these come or go.
# Don't want to have a specific 'global' realm for this as callers register with only one.

	For this to work, each node is going to have to know which neighbours it has and will need a unique name.

	Message format is:

		[MTPOST, messageID|id, destination|String, source|String, visited|array, details|Dict, [normal message content]]

		MTPOST		- Our own message type for routing

		messageId		- Unique message ID generated by sender
		destination		- Unique ID of the destination node or "*" for a broadcast
		source			- The original sender of the message

		visited			- Array of nodes this message has visited (unsure whether to include sender)

		details:
			Expiry		- Date				When this message can be forgotten about (default to +1h)
			PleaseAck	- bool				True if sender requires delivery acknowledgement
			Hops		- integer			How many hops this message has taken (only in discovery)
			Aliases		- Array of Strings	Aliases under which this node can be referred

		message			- normal message	Omitted for a discovery message

	On startup, node sends 'discovery' broadcast via every neighbour
		Contains no content

	On receiving any message:
		If not seen before (only needs to be since startup?):
			Add to 'seen' list (ID, expiry)
		else
			flag as 'duplicate'
		Process message

	On receiving a broadcast (destination = "*"):
		flag as 'broadcast'
		If not duplicate OR is discovery:
			Process message
		If not duplicate:			(Needs to be last as a response might need the above processing to be done to work properly)
			Send to all neighbours not on visited list

	Processing 'discovery':
		Record in route table (sender, hops, neighbour)
		If it was a broadcast:
			Send 'discovery' message direct to sender
		If it was direct:
			Forward as a broadcast to other neighbours

	Processing anything else:
		if duplicate, forget it (mentioned above).

	On receiving any direct message to me:
		If I am sender, process as 'failed to deliver'
		If 'PleaseAck' send 'ack' to sender
		Process the message

	On receiving any direct message to another (X):
		If it is discovery, increment 'details.hops'
		Forward on to a neighbour as for 'On sending to X' below

	On originating a message to X:
		Set sender to self
		Send to X as below:

	On Sending to another (X):
		Add self to 'visited' array
		Find 'X' in route table
		Send to matching neighbour with smallest hop count, not visited

		If there is no matching neighbour, not visited:
			If forwarding (came from neighbour)
				Send back to previous neighbour
			else
				Send to self

		If cannot deliver to neighbour:
			Set its hop count to MAX
			Try next in table

	Failed to deliver:
		This means the message has failed to reach the recipient.

Questions:
	Q: If we receive a message with no visited and the sender is not on our neighbours table, do we add it?
		A: Should never happen, but if already known and hop count in route table == MAX, then reset the hops in the route table?

	Q: How often should we send 'reminder' discovery messages
	Q: When should we 'ping' our neighbours?
		A: Depends on the reliability - let's see how it works out

	Q: Not sure of the use-case for 'PleaseAck' but I'm sure there is one

	Q: Can this be done using external connections to this wamp handling?
		A: I think so!

	Q: When receiving a discovery we may choose not to reply if we have no services to offer, or ignore it if we have no use for it.
		A: If we don't do this, every route table will have all known nodes.  Not sure if this is needed or no.

	Q: Where do we configure neighbours?
		A simple text file somewhere.  Distinct from spider.conf but needs to be one per node and there are several per server.

What achieves this?
	Call from outside WAMP to add handler for message type: 100 = MTPOST
		This should be done by adding an internal WAMP* and saying it should receive all MTPOST messages
	Call WAMP to make connection to each known neighbour
	Send the initial discovery message as above
	When we receive MTPOST, if it's a discovery then reply only if it's a broadcast.
	If it's not a broadcast, re-transmit it as a broadcast, keeping hops and visited intact.

*/

typedef struct wamp_call_t {								// Holds information about an actice call
	const char *callerWampName;								// The name of the calling wamp
	long long callerRequestId;
} wamp_call_t;

typedef struct wamp_callee_t {
	WAMP *wamp;												// WAMP handling this call
	WAMPCB_Invokee	cb_invokee;								// If non-null then a function is handling this call type
	long long registrationId;								// Id under which callee registered
} wamp_callee_t;

typedef struct subscription_info_t {
	long long requestId;
} subscription_info_t;

typedef struct subscription_t {
	long long subscriptionId;
	SPMAP *wamps;											// Maps the WAMPS (by name) that are subscribed, to their requestIds
} subscription_t;

STATIC SPMAP *allWamps = NULL;								// All active wamps by name
STATIC IDMAP *callMap = NULL;								// Calls (wamp_call_t) that have been invoked but not yet yielded
STATIC WAMPCB_NoCallee wampcb_NoCallee = NULL;				// Callback function if there is no callee
STATIC WAMPCB_Invokee wampcb_Invokee = NULL;				// Callback function when a procedure is invoked

STATIC struct wamp_code_t {
	int code;
	const char *name;
} wamp_codes[] = {
	{WAMP_HELLO,			"Hello"},
	{WAMP_WELCOME,			"Welcome"},
	{WAMP_ABORT,			"Abort"},
	{WAMP_GOODBYE,			"Goodbye"},

	{WAMP_ERROR,			"Error"},

	{WAMP_PUBLISH,			"Publish"},
	{WAMP_PUBLISHED,		"Published"},

	{WAMP_SUBSCRIBE,		"Subscribe"},
	{WAMP_SUBSCRIBED,		"Subscribed"},
	{WAMP_UNSUBSCRIBE,		"Unsubscribe"},
	{WAMP_UNSUBSCRIBED,		"Unsubscribed"},
	{WAMP_EVENT,			"Event"},

	{WAMP_CALL,				"Call"},
	{WAMP_RESULT,			"Result"},

	{WAMP_REGISTER,			"Register"},
	{WAMP_REGISTERED,		"Registered"},
	{WAMP_UNREGISTER,		"Unregister"},
	{WAMP_UNREGISTERED,		"Unregistered"},
	{WAMP_INVOCATION,		"Invocation"},
	{WAMP_YIELD,			"Yield"},

	{0,NULL}
};

// IDMAP - maps long long to pointer

IDMAP *idmap_New()												{ return (IDMAP*)spmap_New(); }
void idmap_Delete(IDMAP *im)									{ spmap_Delete((SPMAP*)im); }
void idmap_Reset(IDMAP *im)										{ spmap_Reset((SPMAP*)im); }
void idmap_Clear(IDMAP *im)										{ spmap_Clear((SPMAP*)im); }
int idmap_Count(IDMAP *im)										{ return spmap_Count((SPMAP*)im); }
void idmap_Sort(IDMAP *im, int (*sorter)(const char *, const char *)) { spmap_Sort((SPMAP*)im, sorter); }
void idmap_SortValues(IDMAP *im, int (*sorter)(const char *, const char *)) { spmap_SortValues((SPMAP*)im, sorter); }
void *idmap_GetValueAtIndex(IDMAP *im, int index)                 { return spmap_GetValueAtIndex((SPMAP*)im, index); }
int idmap_GetNextEntry(IDMAP *im, const char **pKey, void **pValue) { return spmap_GetNextEntry((SPMAP*)im, pKey, pValue); }

int idmap_DeleteKey(IDMAP *im, long long id)
{
	char key[18];

	sprintf(key, "%Lx", id);
	return spmap_DeleteKey((SPMAP*)im, key);
}

long long idmap_GetKeyAtIndex(IDMAP *im, int index)
{
	long long result = 0;
	const char *key = spmap_GetKeyAtIndex((SPMAP*)im, index);

	if (key) sscanf(key, "%Lx", &result);

	return result;
}

int idmap_Add(IDMAP *im, long long id, void *value)
{
	char key[18];

	sprintf(key, "%Lx", id);

	return spmap_Add((SPMAP*)im, key, value);
}

void *idmap_GetValue(IDMAP *im, long long id)
{
	char key[18];

	sprintf(key, "%Lx", id);

	return spmap_GetValue((SPMAP*)im, key);
}

long long idmap_GetKey(SIMAP *im, void *value)
{
	long long result = 0;
	const char *key = spmap_GetKey((SPMAP*)im, value);

	if (key) sscanf(key, "%Lx", &result);

	return result;
}

//////////////////////

// Connection provided an incorrect URI for any URI-based attribute of WAMP message,
// such as realm, topic or procedure.
STATIC const char *ErrInvalidUri = "wamp.error.invalid_uri";

// A Dealer could not perform a call, since no procedure is currently
// registered under the given URI.
STATIC const char *ErrNoSuchDomain = "wamp.error.no_such_procedure";

// A procedure could not be registered, since a procedure with the given URI
// is already registered.
STATIC const char *ErrDomainAlreadyExists = "wamp.error.procedure_already_exists";

// A Dealer could not perform an unregister, since the given registration is
// not active.
STATIC const char *ErrNoSuchRegistration = "wamp.error.no_such_registration";

// A Broker could not perform an unsubscribe, since the given subscription is
// not active.
STATIC const char *ErrNoSuchSubscription = "wamp.error.no_such_subscription";

// A call failed, since the given argument types or values are not acceptable
// to the called procedure - in which case the Callee may throw this error. Or
// a Node performing payload validation checked the payload (args / kwargs)
// of a call, call result, call error or publish, and the payload did not
// conform - in which case the Node may throw this error.
STATIC const char *ErrInvalidArgument = "wamp.error.invalid_argument";

// The Connection is shutting down completely - used as a GOODBYE (or aBORT) reason.
STATIC const char *ErrSystemShutdown = "wamp.error.system_shutdown";

// The Connection wants to leave the realm - used as a GOODBYE reason.
STATIC const char *ErrCloseRealm = "wamp.error.close_realm";

// A Connection acknowledges ending of a session - used as a GOOBYE reply reason.
STATIC const char *ErrGoodbyeAndOut = "wamp.error.goodbye_and_out";

// A join, call, register, publish or subscribe failed, since the Connection is not
// authorized to perform the operation.
STATIC const char *ErrNotAuthorized = "wamp.error.not_authorized";

// A Dealer or Broker could not determine if the Connection is authorized to perform
// a join, call, register, publish or subscribe, since the authorization
// operation itself failed. E.g. a custom authorizer ran into an error.
STATIC const char *ErrAuthorizationFailed = "wamp.error.authorization_failed";

// Connection wanted to join a non-existing realm (and the Node did not allow to
// auto-create the realm)
STATIC const char *ErrNoSuchRealm = "wamp.error.no_such_realm";

// A Connection was to be authenticated under a Role that does not (or no longer)
// exists on the Node. For example, the Connection was successfully authenticated,
// but the Role configured does not exists - hence there is some
// misconfiguration in the Node.
STATIC const char *ErrNoSuchRole = "wamp.error.no_such_role";

STATIC int wamp_IsSubscriptionType(int type)
{
	return type >= WAMP_PUBLISH && type < WAMP_CALL;
}

STATIC int wamp_IsCallType(int type)
{
	return type >= WAMP_CALL && type <= WAMP_YIELD;
}

API const char *wamp_Name(WAMP *w)
// Returns the name of a WAMP.  This can later be used in wamp_ByName().
// If you want to refer to a WAMP later, using a name is safer as WAMPs can be deleted...
// WAMP *savedWamp = myWamp; ...... time passes .......  wamp_WriteJson(savedWamp, ...) can fail if it's been deleted in the middle
// const char *savedWamp = wamp_Name(myWamp); .....  WAMP *wamp = wamp_ByName(savedWamp); if (wamp) wamp_WriteJson(... is safe.
{
	return w ? w->name : NULL;
}

API const char *wamp_TypeName(int type)
// Given a WAMP message type number, returns the name
{
	struct wamp_code_t *rover = wamp_codes;

	while (rover->code) {
		if (rover->code == type)
			return rover->name;
		rover++;
	}

	return "Unknown wamp message type";
}

STATIC LogString(WAMP *wamp, const char *prefix, const char *string)
{
	const char *name = "?";
	if (string && *string == '[') {
		name = wamp_TypeName(atoi(string+1));
	}
	const char *wampName = wamp_Name(wamp);
	if (!wampName) wampName = "NULL";

	Log("%-8s(%s): %s - %s", prefix, wampName, name, string);
}

API long long wamp_RandomId()
// Returns a random number 1..2^53-1
{
	static int seeded = 0;

	if (!seeded) {
		seeded = 1;
		srand48(time(NULL));
	}

	long long result = 0;
	while (result == 0) {					// Dangerous but if it doesn't exit, the random number generator has gone weird
		long long a = lrand48();			// Unsigned
		long long b = lrand48();			// Unsigned
		result = a ^ (b<<5);
	}

	return result;
}

API void wamp_Delete(WAMP *w)
{
	if (w) {
		switch (w->connectionType) {
			case 1:							// Websocket
				ws_Delete(w->connection.ws);
				break;
			case 2:							// Rawsocket
				break;
			case 3:							// Code
				break;
		}

		if (w->name)
			spmap_DeleteKey(allWamps, w->name);

		idmap_Delete(w->handlers);
		szDelete(w->name);
		free((char*)w);
	}
}

int wamp_HandleIncomingData(WS *ws, int len, const char *text)
// This function handles UTF8 data coming in on the WebSocket channel.
// Currently this can only be destined for the WAMP system and this is effectively the interface function.
// Returns	0		All went well and was handled
//			1...	Fatal error - close connection
{
////Log("WS-IN(%s): %.*s", ws->name, len, text);

	JSON *j = json_Parse(NULL, &text);

	WAMP *wamp = ws_Info(ws);

	const char *err = json_Error(j);
	if (err) {
		wamp_SendErrorStr(wamp, 0, 0, "Failed to parse JSON", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	if (json_Type(j) != JSON_ARRAY) {
		wamp_SendErrorStr(wamp, 0, 0, "JSON message must be an array", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	if (json_ArrayCount(j) < 1) {
		wamp_SendErrorStr(wamp, 0, 0, "Message must have at least one element", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	JSON *element1 = json_ArrayAt(j, 0);
	if (json_Type(element1) != JSON_INTEGER) {
		wamp_SendErrorStr(wamp, 0, 0, "Message type must be an integer", ErrInvalidArgument, NULL, NULL);
		return 1;
	}
	int messageType = json_AsInteger(element1);

	int result = wamp_Dispatch(wamp, messageType, j);
	json_Delete(j);

	return result;
}

STATIC WAMP *wamp_New(const char *name)
// name must be on the heap
{
	WAMP *w = NEW(WAMP, 1);

	w->name = name;
	w->session = NULL;
	w->realm = NULL;
	w->handlers = idmap_New();

	if (!allWamps) allWamps = spmap_New();

	spmap_Add(allWamps, w->name, (void*)w);			// If it's already there then the world is probably already ending

	return w;
}


API WAMP *wamp_NewPseudo(WAMPCB_Data fn, const char *name)
{
	WAMP *w = wamp_New(hprintf(NULL, "pseudo_%s", name));

	w->connectionType = 3;
	w->connection.fn = fn;

	return w;
}

API WAMP *wamp_NewOnWebsocket(WS *ws)
{
	WAMP *w = wamp_New(hprintf(NULL, "wamp_%s", ws_Name(ws)));

	w->connectionType = 1;
	w->connection.ws = ws;

	ws_SetInfo(ws, w);
	ws_SetUtf8Handler(ws, wamp_HandleIncomingData);

	return w;
}

API WAMP *wamp_ByName(const char *name)
{
	return name ? (WAMP*)spmap_GetValue(allWamps, name) : NULL;
}

STATIC int wamp_Write(WAMP *wamp, const char *message)
// Write a string to this WAMP's output channel
// The string will always be ASCII (JSON) so we don't need a length
// Returns the number of bytes sent
{
	int result = 0;

	if (wamp && message) {
		if (wamp->connectionType == 1) {				// Means it's a WebSocket, which is the only thing we know at the moment
			int fragLen;
			const char *frag = ws_MakeFragment(1, 1, 0, -1, message, &fragLen);

LogString(wamp, "WAMP OUT", message);
			result = ws_WriteHeap(wamp->connection.ws, fragLen, frag);
		} else if (wamp->connectionType == 2) {			// Raw socket
		} else if (wamp->connectionType == 3) {			// Pseudo WAMP
			// We should never get here as this case is picked up in wamp_WriteJson()
		} else {										// TODO: An error really...
		}
	}

	return result;
}

STATIC int wamp_WriteHeap(WAMP *wamp, const char *message)
// Exactly like wamp_Write() but deletes the message afterwards
{
	int result = wamp_Write(wamp, message);
	szDelete(message);

	return result;
}

API void wamp_WriteJson(WAMP *wamp, JSON *json)
{
	const char *message = json_Render(json);
	if (message) {
//Log("wamp_WriteJson(%p, %s)", wamp, message);
		if (wamp->connectionType == 3) {
			(wamp->connection.fn)(wamp, json);
		} else {
			wamp_WriteHeap(wamp, message);
		}
	} else {
		//Log("Duff JSON passed to wamp_SendJson");
	}
}

API void wamp_WriteJsonHeap(WAMP *wamp, JSON *json)
{
	wamp_WriteJson(wamp, json);
	json_Delete(json);
}

API JSON *wamp_NewMessage(int type, long long id)
// Returns a new JSON array with the type filled in and the id if it's non-0
{
	JSON *j = json_NewArray();
	json_ArrayAddInteger(j, type);
	if (id) json_ArrayAddInteger(j, id);

	return j;
}

API void wamp_SendError(WAMP *wamp, int type, long long id, SPMAP *details, const char *uri, JSON *argList, JSON *argDict)
// If details, argList and/or argDict are non-NULL, they become owned, then deleted here.
// Generic error sending
// wamp			- Where we're sending the error
// type			- E.g. WAMP_INVOCATION, WAMP_CALL etc.
// id			- The identifier which will (hopefully) allow the receipient to tie up the error with the message that caused it
// details		- NULL or a details MAP
// uri			- A WAMP error uri
// argList	- NULL or some JSON containing the argument list array
// argDict	- NULL or some JSON containing the argument list dictionary
{
	JSON *j = wamp_NewMessage(WAMP_ERROR, 0);
	json_ArrayAddInteger(j, type);
	json_ArrayAddInteger(j, id);
	JSON *callDetails = json_NewObjectWith(details);
	json_ArrayAdd(j, callDetails);
	json_ArrayAddString(j, -1, uri);
	if (argList) json_ArrayAdd(j, argList);
	if (argDict) json_ArrayAdd(j, argDict);

	wamp_WriteJsonHeap(wamp, j);
}

API void wamp_SendErrorStr(WAMP *wamp, int type, long long id, const char *err, const char *uri, JSON *argList, JSON *argDict)
// If argList and/or argDict are non-NULL, they become owned, then deleted here.
{
	SPMAP *details = spmap_New();
	spmap_Add(details, "error", json_NewString(-1, err));

	wamp_SendError(wamp, type, id, details, uri, argList, argDict);
}

API void wamp_SendResult(WAMP *wamp, long long requestId, JSON *details, JSON *argList, JSON *argDict)
// If details, argList and/or argDict are non-NULL, they become owned, then deleted here.
{
	JSON *j = wamp_NewMessage(WAMP_RESULT, requestId);
	json_ArrayAdd(j, details);
	if (argList) json_ArrayAdd(j, argList);
	if (argDict) json_ArrayAdd(j, argDict);

	wamp_WriteJsonHeap(wamp, j);
}

API void wamp_CloseAbort(WAMP *wamp, int type, const char *uri, const char *reason)
// Close and Abort formats are identical apart from the type
{
	JSON *j = wamp_NewMessage(type, 0);
	JSON *jreason = json_ArrayAdd(j, json_NewObject());
	if (reason)
		json_ObjectAddString(jreason, "reason", -1, reason);
	json_ArrayAddString(j, -1, uri);

	wamp_WriteJsonHeap(wamp, j);
}

API void wamp_Abort(WAMP *wamp, const char *uri, const char *reason)
{
	wamp_CloseAbort(wamp, WAMP_ABORT, uri, reason);
}

API void wamp_Close(WAMP *wamp, const char *uri, const char *reason)
// Sends a WAMP close message with the given reason
{
	wamp_CloseAbort(wamp, WAMP_GOODBYE, uri, reason);
}

STATIC SPMAP *realm_Map()
{
	static SPMAP *realm_map = NULL;

	if (!realm_map) {
		realm_map = spmap_New();

		WAMPREALM *r = NEW(WAMPREALM, 1);
		r->name = strdup("spider");
		r->calleeMapExact = NULL;
		r->calleeMapPrefix = NULL;
		r->calleeMapWildcard = NULL;
		r->redirect = idmap_New();
		r->subMapExact = NULL;
		r->subMapPrefix = NULL;
		r->subMapWildcard = NULL;
		r->allSubscriptions = NULL;

		r->wantForwardSubscriptions = 0;
		r->forwardSubscriptions = NULL;				// Reset forwarding
		r->fwdSubscriptionMap = ssmap_New();
		r->fwdUnsubscriptionMap = ssmap_New();
		r->fwdEventMap = ssmap_New();
		r->fwdPublishMap = ssmap_New();
		spmap_Add(realm_map, "spider", r);
	}

	return realm_map;
}

API int wamp_SetRealm(WAMP *w, const char *name)
{
	WAMPREALM *realm = (WAMPREALM*)spmap_GetValue(realm_Map(), name);
	if (realm) w->realm = realm;

	return !!realm;
}

STATIC WAMPREALM *wamp_RealmByName(const char *name)
{
	return (WAMPREALM*)spmap_GetValue(realm_Map(), name);
}

STATIC WAMPSESSION *wamp_NewSession(WAMPREALM *realm, long long id)
{
	WAMPSESSION *s = NEW(WAMPSESSION, 1);

	if (!id) id = wamp_RandomId();
	s->id = id;
	s->realm = realm;

	return s;
}

STATIC long long session_Id(WAMPSESSION *session)
{
	return session ? session->id : 0;
}

STATIC WAMPSESSION *wamp_GetSession(long long id)
{
	return NULL;
}

STATIC int wamp_Validate(WAMP *wamp, int type, JSON *json)
// Checks the validity of the message, sending an error back if there is a problem
// If there is a problem, an error will have been sent to 'wamp' before returning.
// Returns	0		Ok
//			1...	Problem
{
	int result = 0;

	typedef struct {
		int type;
		int min;
		int max;
		const char *signature;				// I=int, F=Float, N=number, B=bool, O=object, U=Uri, A=Array, S=String
	} valid_t;

	static valid_t valids[] = {
	//	Message type			min	max	Types
		{WAMP_HELLO,			3,	3,	"ISO"},
		{WAMP_WELCOME,			3,	3,	"IIO"},
		{WAMP_ABORT,			3,	3,	"IOU"},
		{WAMP_GOODBYE,			3,	3,	"IOU"},
		{WAMP_ERROR,			5,	7,	"IIIOUAO"},
		{WAMP_PUBLISH,			4,	6,	"IIOUAO"},
		{WAMP_PUBLISHED,		3,	3,	"III"},
		{WAMP_SUBSCRIBE,		4,	4,	"IIOU"},
		{WAMP_SUBSCRIBED,		3,	3,	"III"},
		{WAMP_UNSUBSCRIBE,		3,	3,	"III"},
		{WAMP_UNSUBSCRIBED,		2,	2,	"II"},
		{WAMP_EVENT,			4,	6,	"IIIOAO"},
		{WAMP_REGISTER,			4,	4,	"IIOU"},
		{WAMP_REGISTERED,		3,	3,	"III"},
		{WAMP_UNREGISTER,		3,	3,	"III"},
		{WAMP_UNREGISTERED,		2,	2,	"II"},

		{WAMP_CALL,				4,	6,	"IIOUAO"},
		{WAMP_INVOCATION,		4,	6,	"IIIOAO"},
		{WAMP_YIELD,			3,	5,	"IIOAO"},
		{WAMP_RESULT,			3,	5,	"IIOAO"},

		{0,0,0,0}
	};

	valid_t *v = valids;
	while (v->type) {
		if (v->type == type) {
			int argc = json_ArrayCount(json);

			if (argc < v->min || argc > v->max) {
				const char *msg;

				if (v->min == v->max) {
					msg = hprintf(NULL, "A %s message must have %d elements", wamp_TypeName(type), v->min);
				} else {
					msg = hprintf(NULL, "A %s message must have %d-%d elements", wamp_TypeName(type), v->min, v->max);
				}
				wamp_SendErrorStr(wamp, 0, 0, msg, ErrInvalidArgument, NULL, NULL);
				szDelete(msg);
				result = 1;
				break;
			}

			int i=0;
			const char *expected = NULL;
			for (i=0;i<argc;i++) {
				char check = v->signature[i];
				char actual = json_Type(json_ArrayAt(json, i));

				if (check == 'I' && actual != JSON_INTEGER) {
					expected = "INTEGER";
				} else if (check == 'N' && actual != JSON_FLOAT && actual != JSON_INTEGER) {
					expected = "NUMBER";
				} else if (check == 'B' && actual != JSON_BOOL) {
					expected = "true or false";
				} else if (check == 'O' && actual != JSON_OBJECT) {
					expected = "object";
				} else if (check == 'A' && actual != JSON_ARRAY) {
					expected = "array";
				} else if (check == 'U' && actual != JSON_STRING) {
					expected = "URI";
				} else if (check == 'S' && actual != JSON_STRING) {
					expected = "string";
				}

				if (expected) {
					const char *found = "something else";
					if (actual == JSON_INTEGER)	found = "integer";
					else if (actual == JSON_FLOAT) found = "float";
					else if (actual == JSON_BOOL) found = "boolean";
					else if (actual == JSON_NULL) found = "null";
					else if (actual == JSON_OBJECT) found = "object";
					else if (actual == JSON_ARRAY) found = "array";
					else if (actual == JSON_STRING) found = "string";

					const char *msg = hprintf(NULL, "Message type %d (%s), element %d should be %s not %s", type, wamp_TypeName(type), i+1, expected, found);
					wamp_SendErrorStr(wamp, 0, 0, msg, ErrInvalidArgument, NULL, NULL);
					szDelete(msg);
					result = 2;
					break;
				}
			}

			break;
		}
		v++;
	}

	return result;
}

API void wamp_CallbackNoCallee(WAMPCB_NoCallee cb)
{
	wampcb_NoCallee = cb;
}

API void wamp_RegisterInvokee(WAMPCB_Invokee cb)
{
	wampcb_Invokee = cb;
}

char *mystrtok_r(char *s, char c, char **next)
// strtok_r doesn't seem to want to return empty components and we need that functionality
// It's slightly different as 's2' is actually just a char as that's all I need
{
	char *result = s;
	if (!result) result = *next;
	if (result) {
		char *end = strchr(result, c);

		if (end) *end++ = '\0';
		*next = end;
	}

	return result;
}

STATIC int wamp_WildcardMatch(const char *wildcard, const char *match)
// Taking a wildcard such as mtxml..thing and a match such as mtxml.specific.thing, returns 1 for a match or 0 for not
{
	int matched = 1;

	char *next1;
	char *next2;

	char *wildcardCopy = strdup(wildcard);
	char *matchCopy = strdup(match);
	char *w = wildcardCopy;
	char *m = matchCopy;
	for (;;) {
		const char *wildcardComponent = mystrtok_r(w, '.', &next1);
		const char *matchComponent = mystrtok_r(m, '.', &next2);

		if (!wildcardComponent && !matchComponent)									// We've matched
			break;

		if (!wildcardComponent || !matchComponent) {								// One has ended early
			matched = 0;
			break;
		}

		if (*wildcardComponent && strcmp(wildcardComponent, matchComponent)) {		// A component differs
			matched = 0;
			break;
		}

		w = NULL;
		m = NULL;
	}

	free(wildcardCopy);
	free(matchCopy);

	return matched;
}

STATIC int wamp_AddCaller(long long invokeRequestId, WAMP *wamp, long long callRequestId)
// Adds a caller to those currently known.
// Returns	0	Ok
//			1	requestId was already known
{
	if (!callMap)
		callMap = idmap_New();

	wamp_call_t *caller = idmap_GetValue(callMap, invokeRequestId);
//Log("wamp_AddCaller(%Ld, %p (%s), %Ld)", invokeRequestId, wamp,wamp_Name(wamp), callRequestId);

	if (caller)
		return 1;

	caller = NEW(wamp_call_t, 1);
	caller->callerWampName = strdup(wamp_Name(wamp));
	caller->callerRequestId = callRequestId;

//Log("idmap_Add(%p, %Ld, %p)", callMap, invokeRequestId, caller);
	idmap_Add(callMap, invokeRequestId, caller);
//wamp_call_t *testcaller = idmap_GetValue(callMap, invokeRequestId);
//Log("AAA Caller %p = idmap_GetValue(%p, %Ld)", testcaller, callMap, invokeRequestId);

	return 0;
}

STATIC const char *wamp_FindAndRemoveCaller(long long requestId, long long *pcallerRequestId)
// Returns a string on the heap
{
	const char *result = NULL;

//Log("wamp_FindAndRemoveCaller(%Ld) - callMap = %p", requestId, callMap);
	if (callMap) {
		wamp_call_t *caller = idmap_GetValue(callMap, requestId);

		if (caller) {
			idmap_DeleteKey(callMap, requestId);
			result = caller->callerWampName;
			if (pcallerRequestId) *pcallerRequestId = caller->callerRequestId;
			free((char*)caller);
		}
//Log("BBB Caller %p = idmap_GetValue(%p, %Ld)", caller, callMap, requestId);
	}

//Log("Returning '%s'", result);
	return result;
}

STATIC wamp_callee_t *wamp_FindCallee(WAMP *wamp, const char *procedure)
{
//Log("wamp_FindCallee(%p, '%s')", wamp, procedure);
	wamp_callee_t *result = NULL;
	WAMPREALM *realm = wamp->realm;

	if (realm->calleeMapExact) {												// Check for an exact match
		result = (wamp_callee_t*)spmap_GetValue(realm->calleeMapExact, procedure);
	}

	if (!result && realm->calleeMapPrefix) {									// Not found, Check for a prefix match
		const char *name;
		void *value;

		spmap_Reset(realm->calleeMapPrefix);
		while(spmap_GetNextEntry(realm->calleeMapPrefix, &name, &value)) {
			if (!strncmp(procedure, name, strlen(name))) {
				result = (wamp_callee_t*)value;
				break;
			}
		}
	}

	if (!result && realm->calleeMapWildcard) {									// Not found, Check for a wildcard match
		const char *name;
		void *value;

		spmap_Reset(realm->calleeMapWildcard);
		while(spmap_GetNextEntry(realm->calleeMapWildcard, &name, &value)) {
			if (wamp_WildcardMatch(procedure, name)) {
				result = (wamp_callee_t*)value;
				break;
			}
		}
	}

	if (!result && wampcb_NoCallee) {
		int whatToDo = (*wampcb_NoCallee)(procedure);							// Give the callback chance to register one

		if (whatToDo) {															// It says it might work if you try again
			WAMPCB_NoCallee temp = wampcb_NoCallee;								// Stop us repeatedly calling
			wampcb_NoCallee = NULL;

			result = wamp_FindCallee(wamp, procedure);							// Try again

			wampcb_NoCallee = temp;
		}
	}

	return result;
}

STATIC void wamp_NoInvokee(WAMP *wamp, long long requestId, const char *procedure, JSON *list, JSON *dict)
// Called when we've been invoked but we haven't a function registered to handle it
{
	wamp_SendError(wamp, WAMP_INVOCATION, requestId, NULL, "error.no_such_procedure", list, dict);
//	JSON *invErr = json_NewArray();
//	json_ArrayAddInteger(invErr, WAMP_ERROR);
//	json_ArrayAddInteger(invErr, WAMP_INVOCATION);
//	json_ArrayAddInteger(invErr, requestId);
//	JSON *err = json_NewArray();
//	json_ArrayAddString(err, -1, "callee is unable to handle anything");
//	json_ArrayAdd(invErr, err);

//	wamp_WriteJsonHeap(wamp, invErr);
}

API int wamp_Hello(WAMP *wamp, const char *realm, JSON *opts)
// Does the work of 'helloing' a wamp connection, which is useful if we want to create an already registered
// channel.  E.g. Connecting a legacy API handler.
// Returns	0	Everything went swimmingly
//			1	Was already in a realm
//			2	Realm didn't accept the connection (no such realm)
//			3	Was already in a session
{
	if (wamp->realm) return 1;
	wamp->realm = wamp_RealmByName(realm);
	if (!wamp->realm) return 2;

	if (wamp->session) return 3;

	wamp->session = wamp_NewSession(wamp->realm, 0);
	long long id = session_Id(wamp->session);
}

STATIC long long wamp_RegisterAnyCallee(WAMPREALM *realm, WAMP *wamp, const char *match, const char *invoke, const char *procedure, WAMPCB_Invokee invokee)
// To register an internal invokee...
// realm		realm as named in calling wamp_RegisterInternalCallee()
// wamp			NULL
// match		"exact", "prefix" or "wildcard"
// invoke		"single", "roundrobin", "random", "first" or "last"
// procedure	Named procedure (or prefix etc)
// invokee		Callback procedure to handle
//
// To register an invokee on a WAMP
// realm		realm from the wamp
// wamp			The wamp as registered
// match		"exact", "prefix" or "wildcard"
// invoke		"single", "roundrobin", "random", "first" or "last"
// procedure	NULL
// invokee		Callback procedure to handle
//
// Returns	registrationId	All went ok
//			-1				Realm not known
//			-2				Match type not known (must be "exact", "prefix" or "wildcard")
//			-3				Invoke type not known (must be "single", "roundrobin", "random", "first" or "last")
{
	if (!realm) return -1;

	SPMAP **pmap;
	if (!strcmp(match, "exact"))
		pmap = &realm->calleeMapExact;
	else if (!strcmp(match, "prefix"))
		pmap = &realm->calleeMapPrefix;
	else if (!strcmp(match, "wildcard"))
		pmap = &realm->calleeMapWildcard;
	else {
		return -2;
	}

	int invokePolicy = 0;
	if (!strcmp(invoke, "single"))
		invokePolicy = WAMP_INVOKE_SINGLE;
	else if (!strcmp(invoke, "roundrobin"))
		invokePolicy = WAMP_INVOKE_ROUNDROBIN;
	else if (!strcmp(invoke, "random"))
		invokePolicy = WAMP_INVOKE_RANDOM;
	else if (!strcmp(invoke, "first"))
		invokePolicy = WAMP_INVOKE_FIRST;
	else if (!strcmp(invoke, "last"))
		invokePolicy = WAMP_INVOKE_LAST;
	else {
		return -3;
	}

	long long registrationId = wamp_RandomId();
	wamp_callee_t *callee = NEW(wamp_callee_t, 1);
	callee->registrationId = registrationId;
	callee->cb_invokee = invokee;
	callee->wamp = wamp;
	if (!*pmap)
		*pmap = spmap_New();
	spmap_Add(*pmap, procedure, (void*)callee);

	return registrationId;
}

STATIC int wamp_RegisterSubscriber()
{
}

API long long wamp_RegisterWampCallee(WAMP *wamp, const char *match, const char *invoke, const char *procedure)
{
	return wamp_RegisterAnyCallee(wamp->realm, wamp, match, invoke, procedure, NULL);
}

API long long wamp_RegisterInternalCallee(const char *realmName, const char *match, const char *procedure, WAMPCB_Invokee invokee)
// Registers an internal invokee for a realm
// Returns	0	All went ok
//			1	Realm not known
//			2	Match type not known (must be "exact", "prefix" or "wildcard")
{
	WAMPREALM *realm = wamp_RealmByName(realmName);

	return wamp_RegisterAnyCallee(realm, NULL, match, "single", procedure, invokee);
}

API void wamp_RegisterRedirect(const char *realmName, int type, WAMPCB_Handler fn)
// Sets a function that will be called for all messages of the type given for the given realm.
// If the function returns -1, the normal processing will be performed instead.
// Any other value will be returned as the result of wamp_Dispatch() - 0=ok, 1...=error
{
	WAMPREALM *realm = wamp_RealmByName(realmName);

	if (realm) {
//Log("Adding %p as handler for %s on \"%s\" (%p)", fn, wamp_TypeName(type), realmName, realm);
		idmap_Add(realm->redirect, (long long)type, (void*)fn);
	}
}

API void wamp_RegisterHandler(WAMP *wamp, int type, WAMPCB_Handler fn)
{
	idmap_Add(wamp->handlers, (long long)type, (void*)fn);
}

int wamp_HandleHello(WAMP *wamp, JSON *json)
// [2,1003687871946124,{
//		"roles":{
//			"dealer":{"features":{
//				"pattern_based_registration":true,
//				"shared_registration":true,
//				"caller_identification":true,
//				"progressive_call_results":true
//			}},
//			"broker":{"features":{
//				"publisher_identification":true,
//				"pattern_based_subscription":true,
//				"publisher_exclusion":true,
//				"subscriber_blackwhite_listing":true
//			}}
//		}
//	}
// ]
{
	const char *realmName = json_ArrayStringAt(json, 1);
	JSON *opts = json_ArrayAt(json, 2);

	int err = wamp_Hello(wamp, realmName, opts);
	switch (err) {
		case 1:					// Already in a realm (these two should always be the same)
		case 3:					// Already in a session
			wamp_Abort(wamp, ErrInvalidArgument, "WAMP HELLO received within a session");
			return 1;
		case 2:
			wamp_Abort(wamp, "wamp.error.no_such_realm", "I can only accept \"spider\" currently");
			return 2;
	}

	long long id = session_Id(wamp->session);

	WAMPREALM *realm = wamp->realm;
	int canDealer = 1;
	int canBroker = !realm->wantForwardSubscriptions || (realm->wantForwardSubscriptions && realm->forwardSubscriptions);

	JSON *jResponse = wamp_NewMessage(WAMP_WELCOME, id);
	JSON *replyOpts = json_NewObject();
//	json_ObjectAddString(replyOpts, "agent", -1, "MTWAMP");
	JSON *jRoles = json_NewObject();
	if (canDealer) {
		JSON *jObj = json_ObjectAdd(jRoles, "dealer", json_NewObject());
		JSON *jFeatures = json_ObjectAdd(jObj, "features", json_NewObject());
		json_ObjectAdd(jFeatures, "pattern_based_registration", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "shared_registration", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "caller_identification", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "progressive_call_results", json_NewBool(1));
	}
	if (canBroker) {
		JSON *jObj = json_ObjectAdd(jRoles, "broker", json_NewObject());
		JSON *jFeatures = json_ObjectAdd(jObj, "features", json_NewObject());
//		json_ObjectAdd(jFeatures, "publisher_identification", json_NewBool(1));
		json_ObjectAdd(jFeatures, "pattern_based_subscription", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "publisher_exclusion", json_NewBool(1));
//		json_ObjectAdd(jFeatures, "subscriber_blackwhite_listing", json_NewBool(1));
	}
	json_ObjectAdd(replyOpts, "roles", jRoles);
	json_ArrayAdd(jResponse, replyOpts);

	wamp_WriteJsonHeap(wamp, jResponse);

	return 0;
}

STATIC int wamp_HandleWelcome(WAMP *wamp, JSON *json)
{
	wamp->session = wamp_NewSession(wamp->realm, json_ArrayIntegerAt(json, 1));

	return 0;
}

STATIC int wamp_HandleGoodbye(WAMP *wamp, JSON *json)
{
	const char *uri = json_ArrayStringAt(json, 2);

	if (strcmp(uri, ErrGoodbyeAndOut)) {					// Don't respond if they're saying 'goodbye and out'
		wamp_Close(wamp, ErrGoodbyeAndOut, NULL);
	}
	return 0;
}

STATIC int wamp_HandleError(WAMP *wamp, JSON *json)
{
Log("We've received an error message: %s", json_Render(json));

	return 0;
}

STATIC int wamp_HandleRegister(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *procedure = json_ArrayStringAt(json, 3);

	const char *match = "exact";
	JSON *jMatch = (JSON*)spmap_GetValue(options, "match");
	if (jMatch) {
		if (!json_IsString(jMatch)) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "Match value must be a string", "wamp.error.cannot_register", NULL, NULL);
			return 1;
		}
		match = json_AsString(jMatch);
	}

	const char *invoke = "single";
	JSON *jInvoke = (JSON*)spmap_GetValue(options, "invoke");
	if (jInvoke) {
		if (!json_IsString(jInvoke)) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "Invoke value must be a string", "wamp.error.cannot_register", NULL, NULL);
			return 1;
		}
		invoke = json_AsString(jInvoke);
	}

	double priority = 0.5;
	JSON *jInvoke = (JSON*)spmap_GetValue(options, "priority");
	if (jInvoke) {
		if (!json_IsNumber(jInvoke)) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "Priority value must be a number", "wamp.error.cannot_register", NULL, NULL);
			return 1;
		}
		invoke = json_AsFloat(jInvoke);
	}

	long long registrationId = wamp_RegisterWampCallee(wamp, match, invoke, procedure);
	if (registrationId < 0) {
		wamp_SendError(wamp, WAMP_REGISTER, requestId, NULL, "wamp.error.cannot_register", NULL, NULL);
		return 1;
	}

	JSON *j = wamp_NewMessage(WAMP_REGISTERED, requestId);
	json_ArrayAddInteger(j, registrationId);

	wamp_WriteJsonHeap(wamp, j);
	return 1;
}

STATIC int wamp_HandleRegistered(WAMP *wamp, JSON *json)
{
	return 1;
}

STATIC int wamp_HandleCall(WAMP *wamp, JSON *json)
{
	long long callRequestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *procedure = json_ArrayStringAt(json, 3);
	JSON *argList = json_ArrayTakeAt(json, 4);
	JSON *argDict = json_ArrayTakeAt(json, 4);

	wamp_callee_t *callee = wamp_FindCallee(wamp, procedure);
	//Log("- Looked for callee for %s, found %p", procedure, callee);
	if (!callee) {
		wamp_SendError(wamp, WAMP_CALL, callRequestId, NULL, "wamp.error.no_such_procedure", NULL, NULL);
		return 1;
	}
	long long requestId = wamp_RandomId();


	if (callee->cb_invokee) {
		(callee->cb_invokee)(wamp, callRequestId, procedure, argList, argDict);
		json_Delete(argList);
		json_Delete(argDict);
	} else {
		wamp_AddCaller(requestId, wamp, callRequestId);

		JSON *j = wamp_NewMessage(WAMP_INVOCATION, requestId);
		json_ArrayAddInteger(j, callee->registrationId);
		JSON *callDetails = json_NewObject();
		json_ObjectAddString(callDetails, "procedure", -1, procedure);
		json_ArrayAdd(j, callDetails);
		if (argList) json_ArrayAdd(j, argList);
		if (argDict) json_ArrayAdd(j, argDict);

		wamp_WriteJsonHeap(callee->wamp, j);
	}

	return 0;
}

STATIC int wamp_HandleInvocation(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long registrationId = json_ArrayIntegerAt(json, 2);
	JSON *details = json_ArrayAt(json, 3);
	JSON *argList = json_ArrayTakeAt(json, 4);
	JSON *argDict = json_ArrayTakeAt(json, 4);

	//Log("INVOCATION: requestId = %Ld", requestId);
	//Log("INVOCATION: registrationId = %Ld", registrationId);
	//Log("INVOCATION: details = %s", json_Render(details));
	//Log("INVOCATION: list = (%p) %s", argList, json_Render(argList));
	//Log("INVOCATION: dict = (%p) %s", argDict, json_Render(argDict));

	const char *procedure = NULL;
	JSON *jProcedure = json_ObjectValue(details, "procedure");
	if (jProcedure && json_Type(jProcedure) == JSON_STRING)
		procedure = json_AsString(jProcedure);

	if (wampcb_Invokee) {
		(*wampcb_Invokee)(wamp, requestId, procedure, argList, argDict);
	} else {
		wamp_NoInvokee(wamp, requestId, procedure, argList, argDict);
	}

	json_Delete(argList);
	json_Delete(argDict);

	return 0;
}

STATIC int wamp_HandleYield(WAMP *wamp, JSON *json)
{
	WAMP *callerWamp = NULL;

	long long requestId = json_ArrayIntegerAt(json, 1);
	long long callerRequestId;
	const char *callerName = wamp_FindAndRemoveCaller(requestId, &callerRequestId);
	//Log("Name of caller = '%s'", callerName);
	if (callerName) {									// Should always find one
		callerWamp = wamp_ByName(callerName);			// May not find one if the wamp has 'gone away' since the call

		//Log("Calling wamp = %p", callerWamp);
		szDelete(callerName);
	}

	if (callerWamp) {									// The caller still exists
		JSON *details = json_ArrayTakeAt(json, 2);
		JSON *resultList = json_ArrayTakeAt(json, 2);
		JSON *resultDict = json_ArrayTakeAt(json, 2);

		wamp_SendResult(callerWamp, callerRequestId, details, resultList, resultDict);
	}
	return 0;
}

STATIC int wamp_HandleSubscribe(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *topic = json_ArrayStringAt(json, 3);
	WAMPREALM *realm = wamp->realm;

//Log("Subscribing topic %s into realm %p", topic, realm);
	const char *match = "exact";
	JSON *jMatch = (JSON*)spmap_GetValue(options, "match");
	if (jMatch) {
		if (json_Type(jMatch) != JSON_STRING) {
			wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "OPTION value must be a string", ErrInvalidArgument, NULL, NULL);
			return 0;
		}
		match = json_AsString(jMatch);
	}

	SPMAP **pmap;
	if (!strcmp(match, "exact"))
		pmap = &realm->subMapExact;
	else if (!strcmp(match, "prefix"))
		pmap = &realm->subMapPrefix;
	else if (!strcmp(match, "wildcard"))
		pmap = &realm->subMapWildcard;
	else {
		wamp_SendErrorStr(wamp, WAMP_REGISTER, requestId, "match must be exact, prefix or wildcard", ErrInvalidArgument, NULL, NULL);
		return 0;
	}
	if (!*pmap)						*pmap = spmap_New();						// Initialise the specific map if necessary
	if (!realm->allSubscriptions)	realm->allSubscriptions = idmap_New();		// Initialise the map of all subscriptions if nec.

	subscription_t *sub = spmap_GetValue(*pmap, topic);
	if (!sub) {
		sub = NEW(subscription_t, 1);
		sub->subscriptionId = wamp_RandomId();
		sub->wamps = spmap_New();
		spmap_Add(*pmap, topic, sub);
		idmap_Add(realm->allSubscriptions, sub->subscriptionId, sub);
	}

	subscription_info_t *subinfo = NEW(subscription_info_t, 1);
	subinfo->requestId = requestId;
	spmap_Add(sub->wamps, wamp_Name(wamp), subinfo);

	long long subscriptionId = sub->subscriptionId;

	JSON *j = wamp_NewMessage(WAMP_SUBSCRIBED, requestId);
	json_ArrayAddInteger(j, subscriptionId);

	wamp_WriteJsonHeap(wamp, j);
	return 0;
}

STATIC int wamp_HandleSubscribed(WAMP *wamp, JSON *json)
{
	Log("Unhandled subscribed message: %s", json_Render(json));
	return 1;
}

STATIC int wamp_HandleUnsubscribe(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long subscriptionId = json_ArrayIntegerAt(json, 2);
	WAMPREALM *realm = wamp->realm;

	if (realm->allSubscriptions) {
		subscription_t *sub = idmap_GetValue(realm->allSubscriptions, subscriptionId);
		const char *wampName = wamp_Name(wamp);

		subscription_info_t *subinfo = spmap_GetValue(sub->wamps, wampName);
		if (subinfo) {
			spmap_DeleteKey(sub->wamps, wampName);
			long long originalRequestId = subinfo->requestId;		// Bugger - we really don't need this!
			free((char*)subinfo);
		} else {
		}

		if (subinfo) {
			JSON *j = wamp_NewMessage(WAMP_UNSUBSCRIBED, requestId);
			wamp_WriteJsonHeap(wamp, j);
		} else {
			wamp_SendErrorStr(wamp, WAMP_UNSUBSCRIBE, requestId, "You were not subscribed", ErrNoSuchSubscription, NULL, NULL);
		}
	}
	return 1;
}

STATIC int wamp_HandleUnsubscribed(WAMP *wamp, JSON *json)
{
	Log("Unhandled unsubscribed message: %s", json_Render(json));
	return 1;
}

STATIC int wamp_HandlePublish(WAMP *wamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	SPMAP *options = json_ArrayObjectAt(json, 2);
	const char *topic = json_ArrayStringAt(json, 3);
	JSON *argList = json_ArrayTakeAt(json, 4);
	JSON *argDict = json_ArrayTakeAt(json, 4);
	WAMPREALM *realm = wamp->realm;

	typedef struct sublist_t {
		struct sublist_t *prev;
		subscription_t *sub;
	} sublist_t;

	sublist_t *subs = NULL;

	if (realm->subMapExact) {											// Check for an exact match
		subscription_t *result = (subscription_t*)spmap_GetValue(realm->subMapExact, topic);
		if (result) {
			sublist_t *sub = NEW(sublist_t, 1);
			sub->sub = result;
			sub->prev = subs;
			subs = sub;
		}
	}

	if (realm->subMapPrefix) {											// Check for a prefix match
		const char *name;
		void *value;

		spmap_Reset(realm->subMapPrefix);
		while(spmap_GetNextEntry(realm->subMapPrefix, &name, &value)) {
			if (!strncmp(topic, name, strlen(name))) {
				subscription_t *result = (subscription_t*)value;

				sublist_t *sub = NEW(sublist_t, 1);
				sub->sub = result;
				sub->prev = subs;
				subs = sub;
			}
		}
	}

	if (realm->subMapWildcard) {										// Check for a wildcard match
		const char *name;
		void *value;

		spmap_Reset(realm->subMapWildcard);
		while(spmap_GetNextEntry(realm->subMapWildcard, &name, &value)) {
			if (wamp_WildcardMatch(name, topic)) {
				subscription_t *result = (subscription_t*)value;

				sublist_t *sub = NEW(sublist_t, 1);
				sub->sub = result;
				sub->prev = subs;
				subs = sub;
			}
		}
	}

	// We now have a linked list of subscribers that match this topic, so we'll set about sending events...
	if (subs) {
		long long publicationId = wamp_RandomId();

		JSON *event = wamp_NewMessage(WAMP_EVENT, 0);
		json_ArrayAddInteger(event, 0);								// This will be replaced by the relevant subscription ID
		json_ArrayAddInteger(event, publicationId);
		JSON *details = json_NewObject();
		json_ObjectAddString(details, "topic", -1, topic);
		json_ArrayAdd(event, details);
		if (argList) json_ArrayAdd(event, argList);
		if (argDict) json_ArrayAdd(event, argDict);

		while (subs) {
			sublist_t *sub = subs;

			long long subscriptionId = sub->sub->subscriptionId;
			spmap_Reset(sub->sub->wamps);
			const char *wampName;
			json_ArraySetAt(event, 1, json_NewInteger(subscriptionId));
			while (spmap_GetNextEntry(sub->sub->wamps, &wampName, NULL)) {
				WAMP *wRecip = wamp_ByName(wampName);

				if (wRecip) {
					wamp_WriteJson(wRecip, event);
				}
			}
			subs=sub->prev;
			free((char*)sub);
		}

		json_Delete(event);
	}

	return 1;
}

STATIC int wamp_HandlePublished(WAMP *wamp, JSON *json)
{
	Log("Unhandled published message: %s", json_Render(json));
	return 1;
}

STATIC int wamp_HandleEvent(WAMP *wamp, JSON *json)
{
	Log("Unhandled event message: %s", json_Render(json));
	return 1;
}

// This set of functions is used if we're forwarding subscription handling to another broker
STATIC int wamp_ForwardSubscribe(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);

	ssmap_Add(wamp->realm->fwdSubscriptionMap, buf, wamp_Name(wamp));       // Remember where this came from
	wamp_WriteJson(fwdWamp, json);

	return 0;
}

STATIC int wamp_ForwardSubscribed(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	long long subscriptionId = json_ArrayIntegerAt(json, 2);
	char buf[30];
	sprintf(buf, "%Ld", requestId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdSubscriptionMap, buf);
	if (sender) {
		char buf[30];
		sprintf(buf, "%Ld", subscriptionId);
		ssmap_Add(wamp->realm->fwdEventMap, buf, sender);                   // Remember who asked for this

		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the SUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("SUBSRIBED(%s) not found", buf);
	}
	return 0;
}

STATIC int wamp_ForwardUnsubscribe(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);

	ssmap_Add(wamp->realm->fwdUnsubscriptionMap, buf, wamp_Name(wamp));       // Remember where this came from
	wamp_WriteJson(fwdWamp, json);

	return 0;
}

STATIC int wamp_ForwardUnsubscribed(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long subscriptionId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", subscriptionId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdUnsubscriptionMap, buf);
	if (sender) {
		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the UNSUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("UNSUBSRIBED(%s) not found", buf);
	}
	return 0;
}

STATIC int wamp_ForwardPublish(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);

	ssmap_Add(wamp->realm->fwdPublishMap, buf, wamp_Name(wamp));            // Remember where this came from
	wamp_WriteJson(fwdWamp, json);

	return 0;
}

STATIC int wamp_ForwardPublished(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long requestId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", requestId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdPublishMap, buf);

	if (sender) {
		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the SUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("SUBSRIBED(%s) not found", buf);
	}
	return 0;
}

STATIC int wamp_ForwardEvent(WAMP *wamp, WAMP *fwdWamp, JSON *json)
{
	long long subscriptionId = json_ArrayIntegerAt(json, 1);
	char buf[30];
	sprintf(buf, "%Ld", subscriptionId);
	const char *sender = ssmap_GetValue(wamp->realm->fwdEventMap, buf);
//Log("Event found (%p, %s) = %s", wamp->realm->fwdEventMap, buf, sender?sender:"NULL");

	if (sender) {
		WAMP *wsender = wamp_ByName(sender);
		if (wsender) {                                      // If no wsender then it's gone away since subscribing
			wamp_WriteJson(wsender, json);                  // Send the SUBSCRIBED message back to the subscriber
		}
	} else {                                                // TODO: Case of a subscribed message when we didn't subscribe...
		Log("In event: SUBSRIBED(%s) not found", buf);
	}
	return 0;
}

API int wamp_SetForwardSubscriptions(const char *realmName, int enable, WAMP *wamp)
{
	if (realmName) {
		WAMPREALM *realm = wamp_RealmByName(realmName);

		if (realm) {
			realm->forwardSubscriptions = wamp ? wamp_Name(wamp) : NULL;
			realm->wantForwardSubscriptions = enable;
			return 0;
		}
	}

	return 1;
}

API int wamp_Dispatch(WAMP *wamp, int type, JSON *json)
// Does whatever needs to be done to deal with a message of type 'type'
// The JSON* provided is definitely an array with at least one element.
// Returns 0 or an error code
{
{const char *text = json_Render(json); LogString(wamp, "WAMP IN", text); szDelete(text);}

	int err = wamp_Validate(wamp, type, json);
	if (err) return err;


	if (type == WAMP_ABORT) {							// We sent a HELLO, the far end didn't like it
		return 1;
	}

	if (type != WAMP_HELLO && type != WAMP_WELCOME && !wamp->session) {			// Trying to say something other than hello and we've not shaken hands yet
		wamp_Abort(wamp, ErrInvalidArgument, "You have not been welcomed");
		return 1;
	}

	WAMP *fwdWamp = NULL;							// Assume we're not forwarding this message

	WAMPCB_Handler fn = (WAMPCB_Handler)idmap_GetValue(wamp->handlers, (long long)type);
	if (fn) {
		int result = (*fn)(wamp, type, json);
		if (result != -1) return result;
	}

	if (wamp->realm) {
		WAMPCB_Handler fn = (WAMPCB_Handler)idmap_GetValue(wamp->realm->redirect, (long long)type);

		if (fn) {
			int result = (*fn)(wamp, type, json);
			if (result != -1) return result;
		}

//Log("Have realm '%s', wantForward = %d, to %s", wamp->realm->name, wamp->realm->wantForwardSubscriptions, wamp->realm->forwardSubscriptions ? wamp->realm->forwardSubscriptions : NULL);
		if (wamp_IsSubscriptionType(type)) {
			if (wamp->realm->wantForwardSubscriptions) {
				fwdWamp = wamp_ByName(wamp->realm->forwardSubscriptions);		// Will be NULL if it's not valid
				if (!fwdWamp) {													// Asked to forward but our wamp's gone...
					wamp_SendError(wamp, 0, 0, NULL, "wamp.cannot_handle_subscriptions", NULL, NULL);
					return 2;
				}
			}
		}

		if (wamp_IsCallType(type)) {
		}
	} else {
//Log("WAMP \"%s\"(%p) with no realm...", wamp_Name(wamp), wamp);
	}

	switch (type) {
	case WAMP_HELLO:		return wamp_HandleHello(wamp, json);
	case WAMP_WELCOME:		return wamp_HandleWelcome(wamp, json);
	case WAMP_GOODBYE:		return wamp_HandleGoodbye(wamp, json);
	case WAMP_ERROR:		return wamp_HandleError(wamp, json);
	case WAMP_REGISTER:		return wamp_HandleRegister(wamp, json);
	case WAMP_REGISTERED:	return wamp_HandleRegistered(wamp, json);
	case WAMP_CALL:			return wamp_HandleCall(wamp, json);
	case WAMP_INVOCATION:	return wamp_HandleInvocation(wamp, json);
	case WAMP_YIELD:		return wamp_HandleYield(wamp, json);
	case WAMP_SUBSCRIBE:	return fwdWamp ? wamp_ForwardSubscribe(wamp, fwdWamp, json)
											  : wamp_HandleSubscribe(wamp, json);
	case WAMP_SUBSCRIBED:	return fwdWamp ? wamp_ForwardSubscribed(wamp, fwdWamp, json)
											  : wamp_HandleSubscribed(wamp, json);
	case WAMP_UNSUBSCRIBE:	return fwdWamp ? wamp_ForwardUnsubscribe(wamp, fwdWamp, json)
											  : wamp_HandleUnsubscribe(wamp, json);
	case WAMP_UNSUBSCRIBED:	return fwdWamp ? wamp_ForwardUnsubscribed(wamp, fwdWamp, json)
											  : wamp_HandleUnsubscribed(wamp, json);
	case WAMP_PUBLISH:		return fwdWamp ? wamp_ForwardPublish(wamp, fwdWamp, json)
											  : wamp_HandlePublish(wamp, json);
	case WAMP_PUBLISHED:	return fwdWamp ? wamp_ForwardPublished(wamp, fwdWamp, json)
											  : wamp_HandlePublished(wamp, json);
	case WAMP_EVENT:		return fwdWamp ? wamp_ForwardEvent(wamp, fwdWamp, json)
											  : wamp_HandleEvent(wamp, json);
	default:
		{
			const char *msg = hprintf(NULL, "I can't handle a '%s' message (yet)", wamp_TypeName(type));
			wamp_SendErrorStr(wamp, type, 0, msg, ErrInvalidArgument, NULL, NULL);
			szDelete(msg);
		}
	}

	return 0;
}
