
#ifndef _MMTS_MESSAGE_H
#define _MMTS_MESSAGE_H

#include <rogxml.h>
#include <mime.h>
#include "mmts-contract.h"
#include <smap.h>

// Values for nWrapper and nWrapped
#define WRAP_NONE		-1			// Message has no XML attached
#define WRAP_UNWRAPPED	0			// Message is not wrapped
#define WRAP_NASP		1			// Nasp wrapper
#define WRAP_EBXML		2			// ebXML wrapper
#define WRAP_FAULT		3			// SOAP Fault 'wrapper'
#define WRAP_ACK		4			// SOAP Acknowledgement 'wrapper'
#define WRAP_ITK		5			// SOAP with header namespace = "http://www.w3.org/2005/08/addressing"

// Values for nLevel
#define LEVEL_UNKNOWN	0			// P1R1 wrapping / behaviour
#define LEVEL_P1R1		11			// P1R1 wrapping / behaviour
#define LEVEL_P1R2		12			// P1R2 wrapping / behaviour

typedef struct msg_attachment {
	int nLen;						// Number of bytes of data
	char *szName;					// Name
	char *szContentType;			// MIME content type
	char *szContentId;				// MIME content ID
	const char *szDescription;		// SOAP decsription
	const char *szReferenceId;		// SOAP eb:id that lies within Reference
	char *data;						// Pointer to the data
} msg_attachment;

typedef struct MSG {
	rogxml *xml;					// HL7 wrapper
	int nWrapper;					// Type of wrapper this should have (See WRAP_xxx above)
	int nWrapped;					// Type of wrapper applied (See WRAP_xxx above)
	int nLevel;						// Level of NPfIT (See LEVEL_xxx above)
	int bIsSync;					// 1 if synchronous (NASP), 0 otherwise (ebXML)
	int bAckRequested;				// Sender would like an acknowledgement
	int bIsAck;						// This is an acknowledgement to something
	int bIsLocalSync;				// Is synchronous as far as local app is concerned
	int bHasPayload;				// 1 if there is a payload
	SSMAP *attrs;					// A map of attributes
	const char *szURI;				// URI attached to incoming message
	const char *szFirstSend;		// YYYYMMDDHHMMSS time of first sending
	const char *szLastSend;			// YYYYMMDDHHMMSS time of most recent sending
	const char *szNextSend;			// YYYYMMDDHHMMSS time of next sending
	int nSends;						// Number of times sent
	int nMaxRetries;				// Most times we're meant to try
	const char *szRetryInterval;	// Retry period in schema time period format
	const char *szContract;			// The name of the contract
	contract_t *contract;			// The contract corresponding to this message

	const char *szToPartyId;		// Where it's going
	const char *szFromPartyId;		// Where it's come from
	const char *szToAsid;			// Where it's going in terms of an ASID
	const char *szFromAsid;			// Where it's come from in terms of an ASID
	const char *szService;			// The service such as urn:nhs:names:services:gp2gp

	const char *szInteractionId;	// Interaction Id taken from wrapper
	const char *szConversationId;	// Conversation Id taken from wrapper
	const char *szContentId;		// Used in cid: part of manifest
	const char *szDescription;		// Used in SOAP part of manifest
	const char *szReferenceId;		// Used in SOAP part of manifest as Reference/@eb:id
	const char *szMessageId;		// Message Id taken from wrapper
	const char *szInternalId;		// Internal Id taken from message
	const char *szWrapperId;		// Populated from incoming messages (should be 'MessageId' but ALWAYS from wrapper)
	const char *szRefToMessageId;	// Referring message id taken from wrapper
	const char *szEndpoint;			// Over-riding endpoint in place of contract
	const char *szSoapAction;		// Over-riding soap action in place of that generated by contract information
	int nAttach;					// Number of attachments
	msg_attachment **attachment;	// List of attachments
	int nHttpCode;					// Code that this came in or should be sent with
	const char *szHttpCodeText;		// Textual part of above
	int nError;						// Error number
	const char *szError;			// and associated text
	int nPid;						// Process ID of controlling process
} MSG;

msg_attachment *msg_NewAttachment(const char *szName, const char *szContentType, const char *szContentId, int len, const char *data);
MSG *msg_New(rogxml *xml);
MSG *msg_NewReply(MSG *mr);
void msg_AppendAttachment(MSG *m, msg_attachment *a);
void msg_InsertAttachment(MSG *m, msg_attachment *a);
MSG *msg_NewFromInternal(rogxml *rx);
rogxml *msg_GetXML(MSG *m);
void msg_SetXML(MSG *m, rogxml *rx);
void msg_SetURI(MSG *m, const char *szURI);
void msg_SetLocalSync(MSG *m, int bSetting);
rogxml *msg_ReleaseXML(MSG *m);
contract_t *msg_GetContract(MSG *m);
int msg_GetAttachmentCount(MSG *m);
msg_attachment *msg_GetAttachment(MSG *m, int n);
const char *msg_GetAttachmentContentType(msg_attachment *a);
const char *msg_GetAttachmentContentId(msg_attachment *a);
const char *msg_GetAttachmentText(msg_attachment *a);
const char *msg_GetAttachmentName(msg_attachment *a);
const char *msg_GetAttachmentDescription(msg_attachment *a);
const char *msg_GetAttachmentReferenceId(msg_attachment *a);
void msg_SetAttachmentDescription(msg_attachment *a, const char *szDescription);
void msg_SetAttachmentReferenceId(msg_attachment *a, const char *szReferenceId);
int msg_GetAttachmentLength(msg_attachment *a);
MSG *msg_NewFromMime(MIME *mime);
MSG *msg_NewError(int nErr, const char *szFmt, ...);
const char *msg_GetErrorText(MSG *m);
int msg_GetErrorNo(MSG *m);
contract_t *msg_FindContract(MSG *m);
int msg_Save(MSG *m, const char *szFilename);
MSG *msg_Load(const char *szFilename);
int msg_IsSync(MSG *m);
int msg_AckRequested(MSG *m);
int msg_IsAck(MSG *m);
void msg_SetDescription(MSG *m, const char *szDescription);
void msg_SetReferenceId(MSG *m, const char *szReferenceId);
const char *msg_GetInteractionId(MSG *m);
const char *msg_GetConversationId(MSG *m, const char *def);
const char *msg_GetContentId(MSG *m, const char *def);
const char *msg_GetDescription(MSG *m);
const char *msg_GetReferenceId(MSG *m);
const char *msg_GetMessageId(MSG *m);
const char *msg_GetWrapperId(MSG *m);
const char *msg_GetInternalId(MSG *m);
const char *msg_GetURI(MSG *m);
const char *msg_GetRefToMessageId(MSG *m);
const char *msg_GetToPartyId(MSG *m);
const char *msg_GetFromPartyId(MSG *m);
const char *msg_GetFirstSend(MSG *m);
const char *msg_GetNextSend(MSG *m);
const char *msg_GetLastSend(MSG *m);
const char *msg_GetRetryInterval(MSG *m);
const char *msg_GetToAsid(MSG *m);
const char *msg_GetFromAsid(MSG *m);
void msg_SetEndpoint(MSG* m, const char *szEndpoint);
const char *msg_GetEndpoint(MSG* m);
void msg_SetSoapAction(MSG* m, const char *szSoapAction);
const char *msg_GetSoapAction(MSG* m);
int msg_GetWrapper(MSG *m);
int msg_GetWrapped(MSG *m);
int msg_GetLevel(MSG *m);
int msg_GetSends(MSG *m);
int msg_GetMaxRetries(MSG *m);
const char *msg_Now();
int msg_MarkSent(MSG *m);
int msg_GetPid(MSG *m);
void msg_SetHasPayload(MSG *m, int bSetting);
int msg_ExtractMessageInfo(MSG *m);
const char *msg_AddPeriod(const char *szTime, const char *szPeriod);
long msg_PeriodToSeconds(const char *szPeriod);
int msg_GetHttpCode(MSG *m);
int msg_GetHttpCodeMajor(MSG *m);
const char *msg_GetHttpCodeText(MSG *m);
void msg_SetHttpCode(MSG *m, int nCode, const char *szText);
void msg_SetAttr(MSG *m, const char *szName, const char *szValue);
const char *msg_Attr(MSG *m, const char *szName);
void msg_SetIntAttr(MSG *m, const char *szName, int nValue);
int msg_IntAttr(MSG *m, const char *szName, int nDef);
void msg_DeleteMessageAttachment(MSG *m, int n);
void msg_Delete(MSG *m);
int msg_IsEbXml(MSG *m);
void msg_SetWrapped(MSG *m, int nWrapper);
void msg_SetWrapper(MSG *m, int nWrapper);
void msg_SetError(MSG *m, int nErr, const char *szFmt, ...);
int msg_HasPayload(MSG *m);
int msg_IsLocalSync(MSG *m);
int msg_Unwrap(MSG *m);
void msg_SetLogDir(const char *szDir);
int msg_IsItk(MSG *m);
int msg_IsNasp(MSG *m);
int msg_IsWrapped(MSG *m);
int msg_FindMethod(MSG *m);

#endif
